<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:pref="http://www.w3.org/2002/Math/preference"
      pref:renderer="css">

<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->

<!-- Bootstrap -->
<link href="bootstrap-3.3.7-dist/css/bootstrap.min.css" rel="stylesheet">

<link rel="shortcut icon" href="./voteIcon.ico"/>
<link rel="shortcut icon" href="./voteIcon.ico">
<link rel="stylesheet" type="text/css" href="./vmDefault.css"/>
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.css" />
<link href="https://fonts.googleapis.com/css?family=PT+Sans|Poppins|Roboto|Lobster|Bree+Serif|Product+Sans|Montserrat" rel="stylesheet">


<script language="JavaScript1.4" type="text/javascript">
    pageModDate = "7 July 2017 13:09 PDT";
    // last edited by Vishal Mohanty
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/flot/0.8.3/jquery.flot.js"></script>
<script type="text/javascript" src="./sha256.js"></script>
<script type="text/javascript" src="./BigInt.js"></script>
<script type="text/javascript"  src="bootstrap-3.3.7-dist/js/bootstrap.min.js"></script>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<script type="text/javascript">
   $(document).ready(function(){
      // Starting sample size notes
      $("a.toggleStartingSampleNotes").click(function(){
                                                         $(".startingSampleNotes").toggle();
                                                         if ($("a.toggleStartingSampleNotes").text() == 'Show Technical Notes') {
                                                             $("a.toggleStartingSampleNotes").text('Hide technical notes.');
                                                         } else {
                                                             $("a.toggleStartingSampleNotes").text('Show Technical Notes');
                                                         }
                                                         return(false);
                                                        }
                                            );
      // Ending sample size notes
      $("a.toggleEndingSampleNotes").click(function(){
                                                         $(".endingSampleNotes").toggle();
                                                         if ($("a.toggleEndingSampleNotes").text() == 'Show Technical Notes') {
                                                             $("a.toggleEndingSampleNotes").text('Hide technical notes.');
                                                         } else {
                                                             $("a.toggleEndingSampleNotes").text('Show Technical Notes');
                                                         }
                                                         return(false);
                                                        }
                                            );
      // Random sampling notes
      $("a.toggleRandomSampleNotes").click(function(){
                                                         $(".randomSampleNotes").toggle();
                                                         if ($("a.toggleRandomSampleNotes").text() == 'Show Technical Notes') {
                                                             $("a.toggleRandomSampleNotes").text('Hide technical notes.');
                                                         } else {
                                                             $("a.toggleRandomSampleNotes").text('Show Technical Notes');
                                                         }
                                                         return(false);
                                                        }
                                            );
      $(".notes").hide();
      $(".notes").css({color:"#333", 'font-size':"80%", 'margin-left':"5%", 'background-color':'#eee'});
      $("#hideAllProse").click(function(){$("p:not(form p),pre:not(form pre),table:not(form table),ul:not(form ul),li:not(form li),#visualizing,#placeholder,#plotTitle,#considerations" ).toggle();$(".notes").hide();$("#hideAll").show();});
      // set up the first contest
      addContest();
      $("#nBallots").change(function(){$('#nObj').val(this.value);updateVotes();});
      //$("#addContestButton").click(function(){addContest();});
      //$("#removeContestButton").click(function(){removeContest();});
      $("input[type=text]").focus(function(){this.select();});
      $("#risk").change(function(){updateVotes();});
      $("#nextItem").click(function(){nextSample();});
      $("#reset").click(function(){resetMe();});
      //$("#voteForContest").change(function(){updateVotes();});
      $("#showSequence").change(function(){writeList();});
      $("#showHash").change(function(){writeList();});
      $("#lookUpBallot").click(function(){
            lookUpBallots($('#ballotList').val().split(',').sort(numberLessThan), true);
      });
   });
// ------------------------------------

/*Global variables declaration*/
        var candidates = [];
        var winners = [];
        var losers = [];
        var names = [];
        var waldFactor = [];
        var ballots;
        var risk;
        var wf1=0.0; //Wald factor 1
        var wf2 = 0.0; //Wald factor 2

/*finding the minimum margin*/
        var minMargin;
        var testStatistics;

/*Hashing function*/
        var hasher;
        var sample = new Array(3);
        sample[0] = new Array();
        sample[1] = new Array();
        sample[2] = new Array();
        var manifest = null; //For parse manifest

/*Function which sets up the contest
No Parameters
Returns true upon successfull execution*/
        function addContest() {  
            candidates.push([]); //Creates new contest
            names.push([]);
            winners.push([]);
            losers.push([]);
            var conStr = (candidates.length-1).toString();

            //Setting up the contest name and adding and removing candidate buttons, also the candidate fields
            var str = '<hr align="left" id="hrCon' + conStr + '"><div class="form-group" id="contest' + conStr + '" contest="' + conStr + '">' +
                      '<label for="contestName' + conStr + '">Contest Name: </label>' +
                      '<input class="form-control" type="text" size="80" placeholder="Contest" id="contestName' + conStr + '" class="contestName" /><br />' +
                      '<p><span class="label">Reported Votes:</span></p></div><br />' +
                      '<div class="addCandidate" id="addCandidate' + conStr + '" contest="' + conStr + '">' +
                      '<button class="btn btn-success" type="button" id="addCandidateButton' + conStr +
                      '" value="Add Candidate' +
                      '" contest="' + conStr + '">Add Candidate</button>&nbsp;&nbsp;' +
                      '<button class="btn btn-danger" type="button" id="removeCandidateButton' + conStr +
                      '" value="Remove Last Candidate' +
                      '" contest="' + conStr + '">Remove Last Candidate</button></div>';
            $(".contestList").append(str);

            //Add initially 2 candidates
            $("#contest" + (candidates.length-1).toString()).append(addCandidate(candidates.length-1));
            $("#contest" + (candidates.length-1).toString()).append(addCandidate(candidates.length-1));

            //Setting up the Add Candidate and Remove Candidate functionalities
            var conRef = "#contest" + conStr;
            var candRefLast = '.candidate.contest' + candidates.length + ':last';
            var thisContest = candidates.length-1;
            $("#contestName" + conStr).blur(function(){names[conStr][0] = this.value;});
            $("#addCandidateButton" + conStr).click(function(){$(conRef).append(addCandidate(conStr));updateVotes();});
            $("#removeCandidateButton" + conStr).click(function(){$(candRefLast).remove();
                                                                  candidates[thisContest].pop();
                                                                  names[thisContest].pop();
                                                                  updateVotes();}
                                                      );
            return(true);
        }

/*Function which removes most recently added contest
Not needed currently 
        function removeContest(){
            var conStr = (candidates.length-1).toString();
            $("#hrCon" + conStr).remove();
            $("#contest" + conStr).remove();
            $("#addCandidateButton" + conStr).remove();
            $("#removeCandidateButton" + conStr).remove();
            candidates.pop();
            names.pop();
            return(true);
        }*/

/*Function to add a single candidate
No Parameters
Returns a fully setup candidate field*/
        function addCandidate(contest) {
            candidates[contest].push(0); //Adding candidate to current contest
            var theCandidate = (parseInt(contest)+1).toString() + '_' + candidates[contest].length.toString(); //Address next candidate

            //Sets up fields for candidate name and number of votes secured
            return('<form class="form-inline"><div class="candidate contest' + (parseInt(contest)+1).toString() + '" ' +
                   'id="candidate_' +  theCandidate + '">' +
                   '<label for="name' + theCandidate + '">Candidate ' + candidates[contest].length +  ' Name: </label> ' +
                   '<input class="form-control" type="text" value="Candidate '+ candidates[contest].length.toString()+'" size="40" id="name' + theCandidate + '" onblur="names[' + contest + '][' +
                      (candidates[contest].length-1) + ']=this.value;" />' +
                   '<label for="nBallots' + theCandidate + '">&nbsp;&nbsp;Votes: ' + '</label>' +
                   '<input class="form-control" type="number" value="0" min="0" size="10" id="nBallots' + theCandidate + '" onblur="updateVotes()"/></div></form>');
        }

/*Builds the matrix of test statistics and populates the Audit Progress matrix.
Assumes that winners[] and losers[] have been populated.
No Parameters
Returns true upon completion
*/
        function buildTestMatrix() {
            //Setting up the table
            var str = '<div class="testStatistic" id="testStatistic" >' +
                      '<table class="table table-nonfluid" id="testMatrix"><tbody></tbody></table></div>';
            
            //Clearing the existing table
            $(".testTable").empty();
            $(".testTable").append(str);

            str = '';
            str += '<tr><th>Audited Votes</th>';
            for (var i=0; i < candidates.length; i++) {
                //Create the winner's names headers
                for (var W=0; W < winners[i].length; W++) {
                    str += '<th class="info" id="Twinner_' + i + '_' + winners[i][W] + '">' + names[i][winners[i][W]] +
                            '&nbsp;<input type="text" class="voteSpinner" id="votes_for_' + i + '_' + winners[i][W] +
                            '" value="0" /></th>';
                }
                str += '</tr>';

                //Creating the first loser
                str += '<tr id="Tloser_'  + i + '_' + losers[0][0] + '"><th class="info">' + names[0][losers[0][0]] +
                           '&nbsp;<input type="text" class="voteSpinner" id="votes_for_' + i + '_' + losers[0][0] +
                           '" value="0" /></th>';

                //The field reflecting the progress of the auditing
                str += '<td id="T_' + [i, losers[0][0], winners[0][0]].join('_') + '">1</td>';

                //Populating the remaining losers
                for (var L=1; L < losers[i].length; L++) {
                    str += '<tr id="Tloser_'  + i + '_' + losers[i][L] + '"><th class="info">' + names[i][losers[i][L]] +
                           '&nbsp;<input type="text" class="voteSpinner" id="votes_for_' + i + '_' + losers[i][L] +
                           '" value="0" /></th>';
                    str += '</tr>';
                }
            }

            $("#testStatistic tbody").append(str);
            $("#testStatistic td").css('backgroundColor', '#E55');
            $(".voteRow").css('backgroundColor', '#999');
            $(".voteSpinner").spinner({min: 0});

            //In case the number of votes seen for a particular candidate changes, call updateTestStatistic
            for (var i=0; i< candidates.length; i++) {
                $("[id^=votes_for_" + i + "]").change(
                   (function(x){ return function(){updateTestStatistic(x);}})(i));
            }
            $('.ui-spinner-button').click(function() {$(this).siblings('input').change();});
            
            /*
            // populate the Wald factor matrix
            waldFactor = [];
            for (var i=0; i < candidates.length; i++) {
                waldFactor.push({});
                for (var W=0; W < winners[i].length; W++) {
                    for (var L=0; L < losers[i].length; L++) {
                        hashString = winners[i][W] + ',' + losers[i][L];
                        waldFactor[i][hashString] = candidates[i][winners[i][W]] /
                                         (candidates[i][winners[i][W]] + candidates[i][losers[i][L]]);
                    }
                }
            }*/

            //Wald factors necessary for our computation
            var dum = candidates[0].slice().sort(numberLessThan).reverse();
            wf1 = 2.0*dum[0]/(dum[0]+dum[1]);
            wf2 = 2.0*(ballots-dum[0])/(2.0*ballots-dum[0]-dum[1]);

            return(true);
        }
        
/*Function to test the progress of the audit
Parameters: Contest i which in our case is 0 always
No return value*/
        function updateTestStatistic(i) {
            risk = parsePercent($("#risk").val());
            var totVotes = totWinVotes = totLosVotes = 0;
            for (var W=0; W < winners[i].length; W++) {
                vW = parseInt($("#votes_for_" + i + '_' + winners[i][W]).spinner('value'));
                totVotes += vW;
                totWinVotes += vW;}
            for (var L=0; L < losers[i].length; L++) {
                vL = parseInt($("#votes_for_" + i + '_' + losers[i][L]).spinner('value'));
                totVotes += vL;
                totLosVotes += vL;
            }
            
            ts = 1.0/(Math.pow(wf1, totWinVotes) * Math.pow(wf2, totLosVotes));
            $("#T_" + [0, losers[0][0], winners[0][0]].join('_')).text(roundToDig(ts, 2));
                if (ts <= risk) {
                    $("#T_" + [0, losers[0][0], winners[0][0]].join('_')).css('backgroundColor', '#5E5');
                } else {
                    $("#T_" + [0, losers[0][0], winners[0][0]].join('_')).css('backgroundColor', '#E55');
                }
            $("#sizeSoFar_" + i).text("Audited votes for " + $("#contestName" + i).val() + ": " + commify(totVotes));
        }

/*Function to hash the next sequence number
No Parameters
No return value*/
        function hashMe() {
            hasher = new jsSHA($("#seedValue").val() + "," +
                               $("#samNum").val(), "ASCII");
            $("#nObj").val(parseInt($("#nObj").val()));
            if ($("#nObj").val() == 'NaN') {
                $("#nObj").val(1);
            }
            try {
                sample[0].push($("#samNum").val());
                sample[1].push(hasher.getHash("SHA-256", "HEX"));
                sample[2].push(1 +
                                 modInt( str2bigInt(hasher.getHash("SHA-256", "HEX"), 16, 0),
                                          parseInt($("#nObj").val())
                                       )
                               );
                writeList();
                $("#sortedList").val(sample[2].slice().sort(numberLessThan).join(','));
                $("#ballotList").val($("#sortedList").val());
                var deDupeList = sortMultiple(sample[2], numberLessThan);
                $("#sortedDedupeList").val(deDupeList[0].join(','));
                if (vMinMax(deDupeList[1])[1] > 1) {
                     $("#duplicates").val('Ballot, multiplicity\n' + arrayToString(findRepeats(deDupeList)));
                }
            } catch(e) {
            }
        }

/*Function to write the list of ballots selected
No Parameters
Returns true on successfull execution*/
        function writeList() {  // writes the list of ballots selected
            if ($("#showSequence").prop('checked') &
                   $("#showHash").prop('checked') ) {
                $("#list").val('sequence_number, hash value, ballot\n' + arrayToString(sample));
            } else if ($("#showSequence").prop('checked')) {
                $("#list").val('sequence_number, ballot\n' + arrayToString([sample[0],sample[2]]));
            } else if ($("#showHash").prop('checked')) {
                $("#list").val('hash, ballot\n' + arrayToString([sample[1],sample[2]]));
            } else {
                $("#list").val(sample[2].join(','));
            }
            return(true);
        }

/*Initialization function
No Parameters
No return value*/
        function startMe() {   
            clearList();
            hashMe();
        }

/*Function to clear the lists created
No Parameters
No return value*/
        function clearList() {  // clear the lists
            sample = new Array(3);
            sample[0] = new Array();
            sample[1] = new Array();
            sample[2] = new Array();
            $("#list").val('');
            $("#sortedList").val('');
            $("#sortedDedupeList").val('');
            $("#ballotList").val('');
            $("#duplicates").val('');
            if(findMinMargin()) {
                buildTestMatrix();
            }
        }

/*Reset function to reset everything to defaults
No Parameters
No return value*/
        function resetMe() { 
            clearList();
            $("#samNum").val('0');
        }

/*Function which draws the next sample, of #samMany ballots
No Parameters
No return value*/
        function nextSample() {   
            for (var i=0; i < parseInt($("#samMany").val()); i++) {
                $("#samNum").val(parseInt($("#samNum").val()) + 1);
                hashMe();
            }
        }

/*Function which segregatest the candidates into winners and losers and also computes
the Average Sample Number (ASN) of votes
No Parameters
Returns whether there are sufficient candidates & Min Margin is calculated &
sum of votes for candidates doesn't exceed total number of votes*/
    function findMinMargin() {
        ballots = parseInt($("#nBallots").val());
        if (candidates.length > 0) {
               minMargin = ballots;
        } else {
            minMargin = Number.NaN;
        }
        var ballOk = !isNaN(ballots);
        var opsOk = true;
        var votesOk = true;
        var asn = Number.NaN;

        //Reading candidate votes into candidate[] Array
        try {
            asn = 0;
            for (var i=0; i < candidates.length; i++) {
                var cani = 1; //Number of winners
                if (candidates[i].length < cani ) { // not enough candidates
                    opsOk = false;
                }
                for (var j=0; j < candidates[i].length; j++) {
                    candidates[i][j] = parseInt($("#nBallots" + (i+1).toString() + '_' + (j+1).toString()).val());
                }
                if (vSum(candidates[i]) > cani*ballots) { // too many votes
                    votesOk = false;
                }

                //Spliting the group into winners and losers
                var dum = candidates[i].slice().sort(numberLessThan).reverse(); //duplicates and sorts
                minMargin = Math.min(minMargin, dum[cani-1] - dum[cani]);
                winners[i] = [];
                losers[i] = [];
                for (var j=0; j < candidates[i].length; j++) {  // set colors; build winner and loser lists
                    var theCandidate = (i+1).toString() + '_' + (j+1).toString();
                    if (candidates[i][j] > dum[cani]) {
                        $("#candidate_" + theCandidate).css('backgroundColor', '#5e5');
                        winners[i].push(j);
                    } else {
                        $("#candidate_" + theCandidate).css('backgroundColor', '');
                        losers[i].push(j);
                    }
                }

                /* If risk limit has been set; we can calculate sample size if all margins are
                      defined.*/                    
                if (parsePercent($("#risk").val())){                   
                    asn = Math.max(asn, findAsn(ballots,
                              dum[cani-1],
                              dum[cani]));
                }
            }
        }

        //Catching and reporting exceptions 
        //Reseting values in case of error
        catch(e) {
           minMargin = 'undefined';
           asn = 'undefined';
           alert(e);
        }
        if (!opsOk | isNaN(minMargin)) {
            minMargin = 'undefined';
            asn = 'undefined';
            $("#theDilutedMargin").text('Diluted margin: undefined');
            $("#theMargin").text('Smallest margin (votes): undefined');
            $("#asn").text('Expected sample size: undefined');
        }
        //If there are sufficient candidates and min Margin is calculated successfully 
        else {
            $("#theMargin").text('Smallest margin (votes): ' + commify(minMargin) + '');
            $("#theDilutedMargin").text(' Diluted margin: ' + commify(doubleToStr(100*minMargin/ballots,2)) + '%');
            $("#asn").text('Expected sample size: ' + commify(asn) + '');
            buildTestMatrix();
        }
        if (!(opsOk & votesOk & ballOk)) {
            try {
                for (var i=0; i < candidates.length; i++) {
                    var vf = 1;
                    if (candidates[i].length <  vf ) {
                        throw 'Fewer candidates than voting opportunities in contest!';
                    }
                    if (vSum(candidates[i]) > vf*ballots) {
                        throw 'More votes than voting opportunities in contest!';
                    }
                }
            } catch(e) {
                alert(e);
            }
        }
        return(opsOk & votesOk & ballOk);
    }

/* returns Wald's "average sample number" (ASN)
Refer Mohanty Vanessa et. al. for the ASN formula*/
    function findAsn(ballots, vw, vl) {  //
        /* ballots = total ballots in the contest
           vw = ballots cast for the winner of the pair
           vl = ballots cast for the loser of the pair
        */
        try {
            risk = parsePercent($("#risk").val());
            if (vw > vl) {
                pw = vw/ballots;
                pl = vl/ballots;
                zw = Math.log(2.0*pw/(pw+pl));
                zl = Math.log(2.0*(1-pw)/(2.0-pw-pl));
                console.log(pw, pl, zw, zl);
                asn = Math.ceil(
                     (Math.log(1.0/risk))/(pw*zw + (1-pw)*zl));
            } else {
                asn = 'undefined';
            }
        } catch(e) {
            asn = 'undefined';
        }
        return(asn);
    }

/*Function called when the number of votes are updated*/
    function updateVotes() {
        clearSampleSizes();
        //findMinMargin();
        return(true);
    }

/*Function to clear the sample sizes*/
    function clearSampleSizes() {
        $('#startSampleSize').html('&hellip;');
        if (findMinMargin()) {
            buildTestMatrix();
        }
        return(true);
    }

/*Ballot manifest function to look up the ballots as presented in the webpage*/
    function lookUpBallots(whichBallots, sort) {
        for (var i=0; i < whichBallots.length; i++) {
           whichBallots[i] = parseInt(whichBallots[i]);  // the ballots to find
        }
        if (parseManifest()) {
           if (vSum(manifest[1]) != $("#nObj").val()) {
                alert('Error: Number of ballots in the manifest, ' + vSum(manifest[1]).toString() +
                      ' is not equal to the number of ballots in the contest, ' + $("#nObj").val() +'!');
                return(Number.NaN);
            } else if (vMinMax(whichBallots)[1] > vSum(manifest[1])) {
                alert('Error: Requested ballot exceeds the number of ballots in the manifest!');
                return(Number.NaN);
            } else if (vMinMax(whichBallots)[0] < 1) {
                alert('Error: Requested ballot number is negative!');
                return(Number.NaN);
            }
            var manCum = new Array(manifest[0].length);  // cumulative number of ballots in batches
            manCum[0] = 0;
            for (var i=1; i < manifest[0].length; i++) {
               manCum[i] = manCum[i-1] + manifest[1][i-1];
            }
            var lookUp = new Array(3); // ballot (absolute numbering), batch, identifier_in_batch
            lookUp[0] = whichBallots;
            lookUp[1] = new Array(whichBallots.length);
            lookUp[2] = new Array(whichBallots.length);
            for (var i = 0; i < whichBallots.length; i++) {
                var j = 0;
                while (manCum[j] < whichBallots[i]) {
                    j++;
                }
                j--;
                lookUp[1][i] = manifest[0][j];
                if (typeof(manifest[2][j]) == 'object') {
                    lookUp[2][i] = manifest[2][j][whichBallots[i] - manCum[j] - 1];
                } else {
                    lookUp[2][i] = whichBallots[i] - manCum[j] + manifest[2][j] - 1;
                }
            }
            var str = 'sorted_number, ballot, batch_label, which_ballot_in_batch\n';
            for (var i=0; i < lookUp[0].length; i++ ) {
                str += (i+1).toString() + ', ' + lookUp[0][i].toString() + ', ' +
                       lookUp[1][i].toString() + ', ' + lookUp[2][i].toString() + '\n';
            }
        } else {
            str = 'The manifest cannot be parsed.\n' +
                  'Be sure that the each line of the manifest consists of a batch ' +
                  'label followed by a comma and a number or ' +
                  'a colon-separated ballot range or a list of identifiers in parentheses. ' +
                  'There must be exactly one comma per line.\n';
            $("#manifest").val(str + $("#manifest").val());
        }
        $("#lookUp").val(str);
    }

/*Function used to parse through the Ballot input by the user
No Parameters
Returns true on successfull parsing else false*/
    function parseManifest() {
        var stuff = $("#manifest").val().replace(/\n+/gi,'\n').split('\n');
        var grabBagRegExp = /^ *\(.+\) *$/i
        var batches = new Array(3);
        batches[0] = new Array();  // batch labels
        batches[1] = new Array();  // number of ballots in the batch
        batches[2] = new Array();  // number of the first ballot in the batch, or an array of identifiers
        success = true;
        var j = 0;
        for (var i=0; i < stuff.length; i++) {
            if (typeof(stuff[i]) == 'undefined' || stuff[i] == null || stuff[i] == '') {
               continue;
            } else if (stuff[i].indexOf(',') < 0) {
               alert('Error! Line ' + (i+1).toString() + ' of the manifest has no commas: ' +
                      stuff[i].toString());
               success = false;
            }  else {
               var dum = stuff[i].split(',');
               if (dum.length != 2) {
                   alert('Error! Line ' + (i+1).toString() + ' of the manifest does not parse: ' +
                         stuff[i].toString() +
                         ' Be sure it has exactly one comma, separating the label from the ' +
                         'number of ballots or the ballot range.' );
                   success = false;
               } else {
                   batches[0][j] = dum[0];
                   if (dum[1].indexOf(':') >=  0) {
                         var mRange = dum[1].split(':');
                         batches[1][j] = parseInt(mRange[1]) - parseInt(mRange[0]) + 1;
                         batches[2][j] = parseInt(mRange[0]);
                   } else if (grabBagRegExp.test(dum[1])) {
                         batches[2][j] = new Array();
                         batches[2][j] = dum[1].replace(/( *\( *| *\) *)/g,'').replace(/ +/g,' ').split(' ');
                         batches[1][j] = batches[2][j].length;
                   } else {
                         batches[1][j] = parseInt(dum[1]);
                         batches[2][j] = 1;
                   }
                   j++;
               }
            }
        }
        if (success) {
            manifest = batches;
        } else {
            manifest = null;
        }
        return(success);
    }

//  General-purpose utilities
        function numberLessThan(a,b) { // numerical ordering for javascript sort function
            var diff = parseFloat(a)-parseFloat(b);
            if (diff < 0) {
                return(-1);
            } else if (diff == 0) {
               return(0);
            } else {
               return(1);
            }
         }
        function sortMultiple(list,order) { // sort a list, tabulate multiplicity of items. list is unchanged
            var ans = null;
            if (list.length > 0) {
                var temp = list.slice();
                if (typeof(order) != 'undefined' && order != null) {
                   temp.sort(order);
                } else {
                   temp.sort();
                }
                ans = new Array(2);
                ans[0] = new Array();
                ans[1] = new Array();
                ans[0][0] = temp[0];
                ans[1][0] = 1;
                for (var i=1; i < temp.length; i++) {
                   if (temp[i] == ans[0].slice(-1)) {
                       ans[1][ans[1].length-1]++;
                   } else {
                       ans[0].push(temp[i]);
                       ans[1].push(1);
                   }
                }
            }
            return(ans);
        }
        function findRepeats(list) { // find elements with multiplicity greater than one
                                     // in an array generated by sortMultiple()
            var ans = new Array(2);
            ans[0] = new Array();
            ans[1] = new Array();
            for (var i = 0; i < list[0].length; i++) {
                if (list[1][i] > 1) {
                   ans[0].push(list[0][i]);
                   ans[1].push(list[1][i]);
                }
            }
            return(ans);
        }
        function arrayToString(arr) { // formats an array
            var str = '';
            var cols = arr.length;
            var rows = arr[0].length;
            for (var j=0; j < rows; j++) {
                for (var i=0; i < cols; i++) {
                    str+= arr[i][j] + ',';
                }
                str = str.replace(/,$/,'\n');
            }
            return(str);
        }
    function vCum(list) { // vector of cumulative sum
        var list2 = list;
        for (var i = 1; i < list.length; i++ ) {
            list2[i] += list2[i-1];
        }
        return(list2);
    }
    function vMinMax(list){ // returns min and max of list
        var mn;
        var mx;
        if (list.length == 'undefined' || list.length == 0) {
           mn = list;
           mx = list;
        } else {
           mn = list[0];
           mx = list[0];
           for (var i=1; i < list.length; i++) {
               if (mn > list[i]) mn = list[i];
               if (mx < list[i]) mx = list[i];
           }
        }
        var vmnmx =  new Array(mn,mx);
        return(vmnmx);
    }
    function vSum(list) { // computes the sum of the elements of list
        var tot = 0.0;
        for (var i = 0; i < list.length; i++) {
            tot += list[i];
        }
        return(tot);
    }
    function removeAllBlanks(s){
        return(s.replace(/ +/gm,''));
    }
    function commify(num) { // punctuate number strings greater than 1,000 in magnitude
        var str;
        var strA = (removeAllBlanks(num.toString())).toLowerCase();
        if ( (strA.indexOf('e') > -1) || (strA.indexOf('d') > -1) ) {
            str = strA;  // don't mess with exponential notation
        } else {
            str = strA;
            var curLoc = str.length;
            if ( str.indexOf('.') > -1 ) {
                curLoc = str.indexOf('.');
            }
            var negSign = str.indexOf('-');
            for (var loc = curLoc-4; loc > negSign; loc -= 3) {
                str = str.substr(0,loc+1) + ',' + str.substr(loc+1, str.length);
            }
        }
        return(str);
    }
    function parsePercent(s) {
    // parse a number that contains a % sign to turn it into a decimal fraction
        var value;
        if (s.indexOf('%') == -1) {
            value = parseFloat(trimBlanks(removeCommas(s)))
        } else {
            while (s.indexOf('%') != -1) {
                s = s.substring(0,s.indexOf('%')) +
                    s.substring(s.indexOf('%')+1,s.length)
            }
            value = parseFloat(trimBlanks(removeCommas(s)))/100;
        }
        return(value);
    }
    function roundToDig(num, dig) { // rounds a number or list to dig digits after the decimal place
        var powOfTen = Math.pow(10,dig);
        if ((typeof(num)).toLowerCase() == 'number') {
            var fmt = Math.round(num*powOfTen)/powOfTen;
            return(fmt);
        } else if ((typeof(num)).toLowerCase() == 'object' ||
                   (typeof(num)).toLowerCase() == 'array') {
            var fmt = new Array(num.length);
            for (var i = 0; i < num.length; i++) {
                fmt[i] = Math.round(num[i]*powOfTen)/powOfTen;
            }
            return(fmt);
        } else {
            alert('Error #1 in roundToDig(): argument (' + num.toString() + ') is not a number or an array');
            return(Math.NaN);
        }
    }
    function doubleToStr(num,dig) {
      // returns a string representation of num, rounded to dig digits after the decimal
        return(removeAllBlanks(roundToDig(num,dig).toString()));
    }
    function removeCommas(s) { // removes commas from a string
        return(s.replace(/,/gm,''));
    }
    function trimBlanks(s) { // remove leading and trailing spaces
        s = s.replace(/^ +/gm,'');
        s = s.replace(/ +$/gm,'');
        return(s);
    }
// -->
</script>

<title>Simple Ballot Polling Audit for India</title>

</head>

<body onload="startMe();resetMe();" style="font-family: Montserrat;">

</head>
<div id="bodyDiv">
<nav class="navbar navbar-inverse">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <!--div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#">Home</a>
    </div-->

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
        <ul class="nav navbar-nav">
            <li><a href="simpleBP.html">HOME</a>
        </ul>
      <ul class="nav navbar-nav">
        <li><a href="overall.html">EFFICIENT AUDITING OF INDIAN ELECTIONS<span class="sr-only">(current)</span></a></li>
        </ul>
        <ul class="nav navbar-nav">
        <li><a href="https://www.stat.berkeley.edu/~stark/Vote/auditTools.htm">STARK'S BALLOT COMPARISON AUDIT</a></li></ul>
        <ul class="nav navbar-nav">
        <li><a href="https://www.stat.berkeley.edu/~stark/Vote/ballotPollTools.htm">STARK'S BALLOT POLLING AUDIT</a></li></ul>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="developersSimpleBP.html">DEVELOPERS</a></li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

<h1>
    <center>SIMPLE BALLOT POLLING FOR INDIA</center>
</h1>

<div>

  <!-- Nav tabs -->
  <ul class="nav nav-tabs" role="tablist">
    <li role="presentation" class="active"><a href="#theory" aria-controls="theory" role="tab" data-toggle="tab">THEORY</a></li>
    <li role="presentation"><a href="#contest" aria-controls="contest" role="tab" data-toggle="tab">CONTEST DETAILS</a></li>
    <li role="presentation"><a href="#sampling" aria-controls="sampling" role="tab" data-toggle="tab">RANDOM SAMPLING</a></li>
    <li role="presentation"><a href="#lookup" aria-controls="lookup" role="tab" data-toggle="tab">BALLOT LOOK-UP</a></li>
    <li role="presentation"><a href="#wald" aria-controls="wald" role="tab" data-toggle="tab">AUDIT PROGRESS TOOL</a></li>
    <!--li role="presentation"><a href="#technical" aria-controls="technical" role="tab" data-toggle="tab">Technical Notes</a></li-->
  </ul>

  <!-- Tab panes -->
  <div class="tab-content">
    <div role="tabpanel" class="tab-pane active" id="theory">
        <p>
        This page implements some tools to conduct <b>Simple Ballot-Polling</b> risk-limiting audits as described in
        <a href="#">Auditing of Indian Elections</a>, by Mohanty, Vanessa et.al.
        
        For the previous versions of <b>Ballot Polling</b> risk-limiting audit go to Philip Stark's page
        using the navbar on the top.

        For an implementation of tools for <b>Ballot Comparison</b> risk-limiting audits navigate to 
        Philip Stark's webpage titled "Ballot Comparison Audit".
        </p>

        <!--p id="hideAll">
        To hide or show everything but the tools <button type="button" class="btn btn-default" id="hideAllProse">Click Here</button>
        </p-->
        <div class="panel panel-primary">
            <div class="panel-heading">THEORY</div>
            <div class="panel-body">

                <p>
                A <b>Risk-Limiting Audit</b>, also sometimes referred to as the Result-Conforming Audit
                is a method of post-election audit designed to confirm the election results by examining a small sample of
                the votes. The <b>Risk Limit</b> is the maximum probability that the audit will not detect
                any error in election result when it is present. The error here refers to the case when the
                candidate/party declared as the winner in a given constituency is not the actual winner who
                would be reported by a full-hand manual count of the votes. 
                </p>

                <p>
                There are quite a many tools for performing risk-limiting audit, the prominent of them being the
                Ballot Polling and the Ballot Comparison Audit. This page implemenets the tools for performing 
                Ballot Polling Audit in a simpler manner. The original Ballot Polling audit as implemented by 
                Philip Stark can be found on his webpage. Stark has also developed tools for <b>Ballot Comparison Audit</b>
                which can be reached using the navigation links on the top of the page.
                </p>


                <p>
                The expected sample size calculations for this method depend on the risk limit and the
                reported margins. It is calculated assuming that the reported margins are correct.
                </p>

                <p>
                Risk limiting method audits the ballots at random using a random number generator. If the random sample gives
                sufficient evidence that the election outcome is correct then the audit stops. Else if convincing evidence 
                is not attained, we keep auditing the ballots until we have audited all the ballots, in which case the 
                exact election outcome is known to us. This is based on the assumption that the manual auditing represents
                the ground truth and is error-free. 
                </p>

                <p>
                The tools on this webpage have been divided into sections depending upon their usage. The following lists the
                tools and their utility in the audit process.
                </p>

                <ul>
                <li><b>Contest Details: </b> In this you have to fill in the information about the contest which will help in
                interpreting the results.  </li>
                <li><b>Random Sampling: </b>This helps you to generate a random sequence of numbers which
                tell the sequence in which the ballots should be audited.</li>
                <li><b>Ballot Look-up: </b>This will help find those ballots using a ballot manifest</li>
                <li><b>Wald's Probability Ratio Test: </b>This is a live tool used to determine whether the audit can stop,
                given the votes on the ballots in the sample.</li>
                </ul>


            </div>
        </div>
    </div>

    <div role="tabpanel" class="tab-pane" id="contest">
        <div class="panel panel-primary">
            <div class="panel-heading">INITIAL SAMPLE SIZE</div>
            <div class="panel-body">
                <p>
                The initial sample size tool lets you enter the particulars of the contest to be
                audited, the total ballots cast in the contest, and the vote totals for each
                candidate in the contest.
                The form helps you anticipate the number of randomly selected
                ballots that might need to be inspected to attain a given limit on the risk,
                under the assumption that the reported percentages for each candidate
                are correct.
                It is completely legitimate to sample one at a time and check whether enough have been
                sampled using the <b>Audit Progress Tool</b> but this
                form can help auditors anticipate how many ballots the audit is likely to require
                and to retrieve ballots more efficiently, by reducing the number of times a given batch of
                ballots is opened.
                </p>

                <p>
                Enter the details in the form as per the following guidelines.
                <ul>
                    <li>Enter the total number of ballots cast in the contest.</li>
                    <li>Specify the name of the contest.</li>
                    <li>Add or remove the required number of candidates using the appropriate buttons.</li>
                    <li>Enter the candidate name and the reported number of votes secured by him/her in the contest.</li>
                    <li>Specify the risk-limit to which to audit the contest.
                </ul>
                </p>

                <p>
                Once you are done filling up all the details, kindly proceed to the next tab to find the random
                sample of ballots to be audited.
                </p>
            </div>
        </div>

        <div class="panel panel-primary">
            <div class="panel-heading">CONTEST INFORMATION</div>
            <div class="panel-body">
                <form action="#" method="get">
                        <div class="form-group">
                            <div class="panel panel-default">
                                <div class="panel-heading">CONTEST INFORMATION</div>
                                <div class="panel-body">
                                    <label for="nBallots">Ballots cast in all precincts:</label>
                                    <input class="form-control" type="number" min="0" value="0" size="10" name="nBallots" id="nBallots" />&nbsp;&nbsp;
                                    <span class="label label-default" id="theMargin">Smallest margin (votes): undefined </span>&nbsp;&nbsp;
                                    <span class="label label-default" id="theDilutedMargin">Diluted margin: undefined</span>
                                    <div class="contestList"></div>
                                </div>
                            </div>
                            
                            <div class="panel panel-default">
                                <div class="panel-heading">AUDIT PARAMETERS</div>
                                <div class="panel-body">
                                    <label for="risk">Risk limit:</label>
                                    <input class="form-control" type="text" size="10" name="risk" id="risk" value="5%" />
                                    <span class="label label-default" id="asn">Expected sample size: undefined</span>
                                </div>
                            </div>
                        </div>
                        
                </form>
            </div>
        </div>

        <!--div class="panel panel-info">
            <div class="panel-heading">Considerations for deciding which contests to audit together</div>
            <div class="panel-body">
                <p>
                Taking a larger initial sample can avoid needing to expand the sample later,
                depending on the rate of ballots for each candidate in the sample.
                Avoiding &quot;escalation&quot; can make the audit less complicated.
                </p>
                <p>
                The number of ballots the audit must examine before stopping depends on the smallest
                diluted margin among the contests to be audited together (as well as the risk limit,
                the errors the audit finds, and so on).
                All else equal, the larger the diluted margin is, the smaller the sample size needs to be.
                </p>

                <p>
                Because the diluted margin is the smallest margin in votes divided by the total number of
                ballots cast in all the contests under audit,
                auditing small contests together with large contests can be inefficient:
                Dividing the vote margin in small contests by the number of ballots cast in large contests
                can make the diluted margin very small, which makes the required sample very large.
                </p>

                <p>
                Generally, if two contests overlap substantially&mdash;for instance, if both are jurisdiction-wide
                contests&mdash;it is more economical
                to audit them together:  Fewer ballots will need to be inspected in all.
                Conversely, if two contests do not overlap at all, it is more efficient to audit them separately.
                </p>


                <p>
                Auditing small contests together with (overlapping) large contests generally is not efficient unless the
                vote margin in the small contests is a substantial fraction of the vote margin in the large
                contests.
                That is, auditing small contests that have large percentage margins together with large contests that
                have small percentage margins
                can be efficient, but auditing small contests together with large contests
                that have comparable vote margins generally is not efficient, because it makes the
                diluted margin of the combination much smaller.
                </p>

                <p>
                The tool above can be used to explore whether it makes sense to audit a collection of contests
                together by checking whether the expected sample size when they are audited
                together is greater than the sum of the expected sample sizes when they are audited
                separately.
                (If you experiment with different groupings of contests, be sure to change the entry for
                &quot;Ballots cast in all contests&quot; to reflect only the contests that are to be audited
                together.)
                </p>
            </div>
        </div-->
        <p><a href="#" class="toggleStartingSampleNotes">Show Technical Notes</a></p>
        <p class="startingSampleNotes notes">
        The initial sample size form implements this formula from <a href="#">AIE</a>:
        </p>   
        <p class="startingSampleNotes notes">
        $$ 
            \mbox{ASN} \approx \frac {\ln(1/\alpha)}{ p_w \ln(\frac{p_w\ast (2-p_w-p_r)}{(p_w+p_r)\ast (1-p_w)}) + \ln(\frac{2 - 2p_w}{1-p_w-p_r})},
        $$
        </p>
        <p class="startingSampleNotes notes">
        where \(w\) is a candidate reported to have won, \(r\) is the  runner-up candidate and
        \(p_w\) and \(p_r\) are the percentage of votes won by the winner and the 
        runner-up respectively.
       
    </div>

    <div role="tabpanel" class="tab-pane" id="sampling">
        <div class="panel panel-primary">
            <div class="panel-heading">RANDOM SAMPLING</div>
            <div class="panel-body">
                <p>
                This tool helps generate a pseudo-random sample of ballots.
                To start,
                input a random seed with at least 20 digits (generated by rolling a 10-sided die, for instance),
                the number of ballots from which you want a sample, and the number of ballots you want in the sample.
                Further below, there is a form to help find the individual, randomly selected
                ballots among the batches in which ballots are stored.
                </p>

                    <form action="#" method="get">
                        <div class="panel panel-default">
                            <div class="panel-heading">PSEUDO-RANDOM SAMPLE OF BALLOTS</div>
                            <div class="panel-body">
                                <div class="form-group">
                                    <label for="seedValue">Seed:</label>
                                    <input class="form-control" type="text" size="25" name="seedValue" id="seedValue" onblur="clearList();"
                                        placeholder="Input seed here" />

                                    <label for="nObj">Number of ballots:</label>
                                    <input class="form-control" type="number" min="0" size="10" name="nObj" id="nObj" onblur="clearList();" value="1000"/>

                                    <label for="samNum">Current sample number:</label>
                                    <input class="form-control"type="number" size="10" name="samNum" id="samNum" editable="false" value="1"/>

                                    <label for="samMany">Draw these many ballots:</label>
                                    <input class="form-control" type="number" min="0" size="10" name="samMany" id="samMany" value="1"/>
                                    <br>
                                    <button type="button" class="btn btn-success" name="nextItem" id="nextItem" value="draw sample">Draw Sample</button>
                                    &nbsp; &nbsp;
                                    <button type="button" class="btn btn-danger" name="reset" id="reset" value="reset" >Reset</button>
                                </div>
                            </div>
                            
                        </div>
                </form>
                <form> 
                    <div class="panel panel-default">
                        <div class="panel-heading" for="list">BALLOTS SELECTED</div>
                        <div class="panel-body">
                            <input type="checkbox" name="showSequence" id="showSequence" value="showSequence" checked />
                            <label for="showSequence">show sequence numbers</label>
                            <input type="checkbox" name="showHash" id="showHash" value="showHash" />
                            <label for="showHash">show hash values</label>
                            <textarea class="form-control" rows="10" cols="80" name="list" id="list" readonly="readonly"></textarea>
                        </div>
                    </div>
                    <div class="panel panel-default">
                        <div class="panel-heading" for="sortedList">BALLOTS SELECTED, SORTED</div>
                        <div class="panel-body">
                            <textarea class="form-control" rows="10" cols="80" name="sortedList" id="sortedList" readonly="readonly"></textarea>
                        </div>
                    </div>
                    <div class="panel panel-default">
                        <div class="panel-heading" for="sortedDedupeList">BALLOTS SELECTED, SORTED, DUPLICATES REMOVED</div>
                        <div class="panel-body">
                            <textarea class="form-control" rows="10" cols="80" name="sortedDedupeList" id="sortedDedupeList" readonly="readonly"></textarea>
                        </div>
                    </div>
                    <div class="panel panel-default">
                        <div class="panel-heading" for="duplicates">REPEATED BALLOTS</div>
                        <div class="panel-body">
                            <textarea class="form-control" rows="10" cols="80" name="duplicates" id="duplicates" readonly="readonly"></textarea>
                        </div>
                    </div>
                </form>
                
            </div>
        </div>
        <p>
                <a href="#" class="toggleRandomSampleNotes">Show Technical Notes</a>
                </p>

                <p class="randomSampleNotes notes">
                The &quot;seed,&quot; concatenated with a comma and the &quot;Sample number,&quot; is passed through the
                SHA-256 hash function.
                The result is displayed as &quot;Hashed value (for testing)&quot;.
                The hashed value, interpreted as a hexadecimal number, is divided by
                &quot;Number of objects from which to sample.&quot;
                One is added to the remainder of that division to get &quot;Randomly selected item,&quot;
                which will be a number between 1 and &quot;Number of objects from which to sample,&quot; inclusive.
                Clicking &quot;draw sample&quot; successively adds one to &quot;Sample number&quot; and
                recomputes &quot;Hashed value&quot; and &quot;Randomly selected item&quot;
                &quot;Draw this many objects&quot; times.
                Selected items accumulate in &quot;Ballots selected&quot; (and &quot;Ballots selected, sorted&quot;),
                which reset if the seed or the number of objects changes.
                The same ballot might be selected more than once.
                Duplicates are removed in
                &quot;Ballots selected, duplicates removed.&quot;
                Ballots selected more than once, and the frequencies of those ballots, are in
                &quot;Repeated ballots.&quot;
                Clicking the &quot;reset&quot; button clears the history but leaves the seed.
                </p>

                <p class="randomSampleNotes notes">
                This tool was developed in Javascript by Philip Stark and his collaborators.

                <p class="randomSampleNotes notes">
                    For more detail, see
                <a href="http://statistics.berkeley.edu/~stark/Java/Html/sha256Rand.htm">http://statistics.berkeley.edu/~stark/Java/Html/sha256Rand.htm</a>.
                </p>
    </div>

    <div role="tabpanel" class="tab-pane" id="lookup">
        <div class="panel panel-primary">
            <div class="panel-heading">FIND BALLOTS USING A BALLOT MANIFEST</div>
            <div class="panel-body">
                <p>
                Generally, ballots will be stored in batches, for instance, separated by booth from which they were collected.
                To make it easier to find individual ballots, it helps to have a <em>ballot manifest</em>
                that describes how the ballots are stored.
                For instance, we might have 1,000 ballots stored as follows:
                </p>

                <center>
                    <table class="table table-nonfluid table-bordered">
                    <tr class="info">
                        <th class="col-md-6">Batch Label</th><th class="col-md-6">Ballots</th>
                    </tr>
                    <tr>
                        <td>Polling place booth 1</td> <td>130</td>
                    </tr>
                        <td>Polling place booth 2</td>  <td>172</td>
                    </tr>
                    <tr>
                        <td>Polling place booth 3</td> <td>112</td>
                    </tr>
                        <td>Polling place booth 4</td>  <td>201</td>
                    </tr>
                    <tr>
                        <td>Polling place booth 5</td> <td>197</td>
                    </tr>
                        <td>Polling place booth 5</td>  <td>188</td>
                    </tr>
                    </table>
                </center>


                <p>
                If ballot 500 is selected for audit, which ballot is that?
                If we take the listing of batches in the order given by the manifest, and we
                require that within each batch, the ballots are in an order that does not
                change during the audit, then the 500th ballot is the 86th ballot among the 
                for ballots for polling place booth 4:
                The first three batches have a total of 130+172+112 = 414 ballots.
                The first ballot in the fourth batch is ballot 415.
                Ballot 500 is the 86th ballot in the fourth batch.
                </p>

                <p>
                The ballot look-up tool transforms a list of ballot numbers and a ballot manifest
                into a list of ballots in each batch.
                Batch labels should not contain commas.
                Use a comma to separate each batch label from the number of ballots in that batch
                (or the range of ballot numbers or the set of ballot identifiers as depicted below).
                The manifest should have one line per batch and no empty lines.
                </p>

                <p>
                For instance, to input the ballot manifest above, you would enter:
                </p>

                <p>
                <pre>
                Polling place booth 1, 130
                Polling place booth 2, 172
                Polling place booth 3, 112
                Polling place booth 4, 201
                Polling place booth 5, 197
                Polling place booth 6, 188
                </pre>
                </p>

                <p>
                If all the ballots in the election are numbered sequentially, you may want to specify
                the range of ballots which come from a given polling booth. Also in case of any Provisional
                votes, they can be specified individually for a polling booth. Consider the following table.
                <!--p>
                Some jurisdictions number the ballots cast in an election.
                If all the ballots in an election are numbered sequentially, the numbers on the ballots that contain
                a particular contest might not be sequential.
                For instance, an election might cover precincts 1, 2, and 3, but
                only voters in precincts 1 and 3 are eligible to vote in the contests to be audited with the current sample.
                In the previous example, suppose that the jurisdiction had stamped numbers on all the ballots, sequentially, so that
                the ballots from the polling place in booth 1 were numbered 1 to 130, the vote by mail ballots from booth 1 were
                numbered 131 to 302, the ballots from the polling place in booth 2 were numbered 303 to 414, and so on,
                as summarized in the following table:
                </p-->

                <center>
                    <table class="table table-nonfluid table-bordered">
                    <tr class="info">
                        <th>Batch label</th><th>Ballot Range</th>
                    </tr>
                    <tr>
                        <td>Polling place booth 1</td> <td>1 to 130</td>
                    </tr>
                        <td>Polling place booth 2</td>  <td>131 to 302</td>
                    </tr>
                    <tr>
                        <td>Polling place booth 3</td> <td>303 to 414</td>
                    </tr>
                        <td>Polling place booth 4</td>  <td>415 to 615</td>
                    </tr>
                    <tr>
                        <td>Polling place booth 5</td> <td>616 to 812</td>
                    </tr>
                        <td>Polling place booth 6</td>  <td>813 to 994</td>
                    </tr>
                    <tr>
                        <td>Provisional ballots for booth 1</td> <td>996, 998, 1000</td>
                    </tr>
                    <tr>
                        <td>Provisional ballots for booth 2</td> <td>997</td>
                    </tr>
                    <tr>
                        <td>Provisional ballots for booth 3</td> <td>995, 999</td>
                    </tr>
                    </table>
                </center>

                <p>
                Since the ballots already have numbers on them, it makes sense to look them up using those numbers.
                Each line in the manifest would consist of a batch label and a range of ballot numbers,
                where the range is denoted by a colon,
                or of a batch label and a set of ballot identifiers in parentheses, separated by spaces.
                Ballot ranges cannot have gaps: There can be no missing numbers within the range for
                any single batch.
                (If there is in fact a gap, input the numbers as a set of identifiers, rather than as a range.)
                Again, separate the label from the range or set of ballot numbers by a comma.
                The label must not contain any commas,
                and the range of ballot numbers or set of identifiers must not contain commas.
                In this example, we would enter the ballot manifest as follows:
                </p>

                <p>
                <pre>
                Polling place booth 1, 1:130
                Polling place booth 2, 131:302
                Polling place booth 3, 303:414
                Polling place booth 4, 415:615
                Polling place booth 5, 616:812
                Polling place booth 6, 813:994
                Provisional booth 1, (996 998 1000)
                Provisional booth 3, (995 999)
                </pre>
                </p>

            </div>
        </div>

        <div class="panel panel-primary">
            <div class="panel-heading">BALLOT LOOK-UP TOOL</div>
            <div class="panel-body">
                <form action="#" method="get">
                    <div class="panel panel-default">
                        <div class="panel-heading">BALLOT MANIFEST</div>
                        <div class="panel-body">
                            Each line must have a batch label, a comma, and one of the following:
                            <ol >
                                <li >the number of ballots in the batch</li>
                                <li >A range specified with a colon (e.g., 131:302), or </li>
                                <li >A list of ballot identifiers within parentheses, separated by spaces (e.g., (996 998 1000)).</li>
                                <li >Each line should have exactly one comma.</li>
                            </ol>
                            <textarea class="form-control" rows="10" cols="40" name="manifest" id="manifest"></textarea>
                        </div>
                    </div>
                    <div class="panel panel-default">
                        <div class="panel-heading">BALLOTS TO LOOK UP (SEPARATED BY COMMAS)</div>
                        <div class="panel-body">
                            <textarea class="form-control" rows="10" cols="40" name="ballotList" id="ballotList" ></textarea>
                            <br>
                            <button type="button" class="btn btn-success" id="lookUpBallot" name="lookUpBallot" value="look up ballots">Look Up Ballots</button>
                        </div>
                    </div>
                    <div class="panel panel-default">
                        <div class="panel-heading">SORTED LOOK-UP TABLE</div>
                        <div class="panel-body">
                            <label for="lookUp"></label><br />
                            <textarea class="form-control" rows="10" cols="40" name="lookUp" id="lookUp" readonly="readonly"></textarea>
                        </div>
                    </div>
                </form>
            </div>
        </div>
    </div>     

    <div role="tabpanel" class="tab-pane" id="wald">
        <div class="panel panel-primary">
            <div class="panel-heading">AUDIT PROGRESS TOOL</div>
            <div class="panel-body">
                <p>
                The audit looks at the winner and all the losers together. Every vote for the winner increases
                the value of the probability ratio. Every vote for any of the losers decreases
                that value. If sufficient evidence is found that the election is correct, the audit stops.
                This is indicated by the cell representing the ratio becoming green in colour.
                If the cell is red in colour, we have to continue the audit.
                </p>



                <form action="#" method="get">
                    <div class="panel panel-default">
                        <div class="panel-heading">Audit progress</div>
                        <div class="panel-body">
                            <div class="testTable"></div>
                        </div>
                    </div>

                </form>
            </div>
        </div>
        <p>
                <a href="#" class="toggleEndingSampleNotes">Show Technical Notes</a>
                </p>

                <p class="endingSampleNotes notes">
                The stopping rule implements the following formula from
                <a href="#">AIE</a>:
                If we get a vote for the winner, we multiply the wald probability ratio \(T\) by 
                $$
                    \frac{2\ast p_w}{p_w + p_r}
                $$
                If we get a vote for any of the losers, we multilpy the wald probability ratio \(T\) by
                $$
                    \frac{2-2\ast p_w}{2- p_w - p_r}
                $$
                where \(p_w\) stands for the winner's vote percentage and \(p_r\) stands for the runnerup's
                vote percentage. 
                When \(\frac{1}{T}\) becomes less than \(\alpha\), we have reached the desired confidence level
                and the audit can stop.
                </p>
    </div>
    <!--div role="tabpanel" class="tab-pane" id="technical">
        <h1>Hello!</h1>
    </div-->
</div>

</body>

</html>
