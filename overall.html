<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:pref="http://www.w3.org/2002/Math/preference"
      pref:renderer="css">

<head>
<meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->

    <!-- Bootstrap -->
<link href="bootstrap-3.3.7-dist/css/bootstrap.min.css" rel="stylesheet">

<link rel="shortcut icon" href="./voteIcon.ico"/>
<link rel="shortcut icon" href="./voteIcon.ico"/>
<link rel="stylesheet" type="text/css" href="./pbsDefault.css"/>
<link rel="stylesheet" type="text/css" href="./jquery-ui.min.css" />



<script language="JavaScript1.4" type="text/javascript">
    pageModDate = "19 June 2017 13:09 PDT";
    // copyright 2011&ndash;2017 by P.B. Stark, statistics.berkeley.edu/~stark
    // License CC-BY 2.0 https://creativecommons.org/licenses/by/2.0/
// -->
</script>

<script type="text/javascript" src="./jquery.min.js"></script>
<script type="text/javascript" src="./jquery-ui.min.js"></script>
<script type="text/javascript" src="./jquery.flot.js"></script>
<script type="text/javascript" src="./sha256.js"></script>
<script type="text/javascript" src="./BigInt.js"></script>
<script type="text/javascript"  src="bootstrap-3.3.7-dist/js/bootstrap.min.js"></script>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<script type="text/javascript">
   $(document).ready(function(){
      // Starting sample size notes
      $("a.toggleStartingSampleNotes").click(function(){
                                                         $(".startingSampleNotes").toggle();
                                                         if ($("a.toggleStartingSampleNotes").text() == 'Show technical notes.') {
                                                             $("a.toggleStartingSampleNotes").text('Hide technical notes.');
                                                         } else {
                                                             $("a.toggleStartingSampleNotes").text('Show technical notes.');
                                                         }
                                                         return(false);
                                                        }
                                            );
      // Ending sample size notes
      $("a.toggleEndingSampleNotes").click(function(){
                                                         $(".endingSampleNotes").toggle();
                                                         if ($("a.toggleEndingSampleNotes").text() == 'Show technical notes.') {
                                                             $("a.toggleEndingSampleNotes").text('Hide technical notes.');
                                                         } else {
                                                             $("a.toggleEndingSampleNotes").text('Show technical notes.');
                                                         }
                                                         return(false);
                                                        }
                                            );
      // Random sampling notes
      $("a.toggleRandomSampleNotes").click(function(){
                                                         $(".randomSampleNotes").toggle();
                                                         if ($("a.toggleRandomSampleNotes").text() == 'Show technical notes.') {
                                                             $("a.toggleRandomSampleNotes").text('Hide technical notes.');
                                                         } else {
                                                             $("a.toggleRandomSampleNotes").text('Show technical notes.');
                                                         }
                                                         return(false);
                                                        }
                                            );
      $(".notes").hide();
      $(".notes").css({color:"#333", 'font-size':"80%", 'margin-left':"5%", 'background-color':'#eee'});
      $("#hideAllProse").click(function(){$("p:not(form p),pre:not(form pre),table:not(form table),ul:not(form ul),li:not(form li),#visualizing,#placeholder,#plotTitle,#considerations" ).toggle();$(".notes").hide();$("#hideAll").show();});
      // set up the first contest
      addContest();
      $("#nSeats").change(function(){$('#nObj').val(this.value);updateVotes();});
      $("#nCandi").change(function(){setCandidates()});
      $("#nConsti").change(function(){updateVotes()});
      //$("#addContestButton").click(function(){addContest();});
      //$("#removeContestButton").click(function(){removeContest();});
      $("input[type=text]").focus(function(){this.select();});
      $("#risk").change(function(){updateRisk();});
      //$("#nextItem").click(function(){nextSample();});
      $("#reset").click(function(){resetMe();});
      $("#voteForContest").change(function(){updateVotes();});
      $("#showSequence").change(function(){writeList();});
      //$("#showHash").change(function(){writeList();});
      //$("#lookUpBallot").click(function(){
        //    lookUpBallots($('#ballotList').val().split(',').sort(numberLessThan), true);});
      
   });
// ------------------------------------
/*Global declaration of variables*/
        var parties = [];
        var winners = [];
        var losers = [];
        var names = [];
        var waldFactor = [];
        var ballots;
        var risk;
        var nCandidates, nConstituencies;
        var lastWinner, firstLoser;
        var wf1=0.0;
        var wf2 = 0.0;

/*finding the minimum margin*/
        var minMargin;
        var testStatistics;

/*Function which sets up the contest
No Parameters
Returns true upon successfull execution*/
        function addContest() {  // needs to be modified
            parties.push([]);
            names.push([]);
            winners.push([]);
            losers.push([]);
            var conStr = (parties.length-1).toString();
            var str = '<div class="form-group" id="contest' + conStr + '" contest="' + conStr + '">' +
                      '<label for="contestName' + conStr + '">Contest Name: </label>' +
                      '<input class="form-control" type="text" size="80" placeholder="Contest" id="contestName' + conStr + '" class="contestName" /><br />' +
                      //'<p><span class="label">Reported Votes:</span></p></div>' +
                      '<div class="addCandidate" id="addCandidate' + conStr + '" contest="' + conStr + '"></div>';
                      /*'<button class="btn btn-success" type="button" id="addCandidateButton' + conStr +
                      '" value="Add Candidate' +
                      '" contest="' + conStr + '">Add Candidate</button>&nbsp;&nbsp;' +
                      '<button class="btn btn-danger" type="button" id="removeCandidateButton' + conStr +
                      '" value="Remove Last Candidate' +
                      '" contest="' + conStr + '">Remove Last Candidate</button></div>';*/
            $(".contestList").append(str);
            //$("#contest" + (parties.length-1).toString()).append(addCandidate(parties.length-1));
            //$("#contest" + (parties.length-1).toString()).append(addCandidate(parties.length-1));
            var conRef = "#contest" + conStr;
            var candRefLast = '.candidate.contest' + parties.length + ':last';
            var thisContest = parties.length-1;
            $("#contestName" + conStr).blur(function(){$("#contestName" + conStr).value = this.value;});
            $("#addCandidateButton" + conStr).click(function(){$(conRef).append(addCandidate(conStr));updateVotes();});
            $("#removeCandidateButton" + conStr).click(function(){$(candRefLast).remove();
                                                                  parties[thisContest].pop();
                                                                  names[thisContest].pop();
                                                                  updateVotes();}
                                                      );
            return(true);
        }

/*Function which is called whenever the number of candidates are changed
No Parameters
No return value*/
        function setCandidates(){
            var conStr = "0";
            var conRef = "#contest0";
            var candRefLast = '.candidate.contest' + parties.length + ':last';
            var thisContest = parties.length-1;
            while(parties[thisContest].length>0){
                $(candRefLast).remove();
                parties[thisContest].pop();
                names[thisContest].pop();
            }
            updateVotes();    
            for(var i=0; i<nCandidates; i++){
                $(conRef).append(addCandidate(conStr));
            }
            updateVotes();             
        }
        /*function removeContest() {  // not needed
            var conStr = (parties.length-1).toString();
            $("#hrCon" + conStr).remove();
            $("#contest" + conStr).remove();
            $("#addCandidateButton" + conStr).remove();
            $("#removeCandidateButton" + conStr).remove();
            parties.pop();
            names.pop();
            return(true);
        }*/

/*Function to add a single candidate
No Parameters
Returns a fully setup candidate field*/
        function addCandidate(contest) {
            parties[contest].push(0);
            var theCandidate = (parseInt(contest)+1).toString() + '_' + parties[contest].length.toString();
            names[contest][(parties[contest].length-1)]="Party"+parties[contest].length.toString();
            //$("#nCandi").val()=$("#nCandi").val()+1;
            return('<form class="form-inline"><div class="candidate contest' + (parseInt(contest)+1).toString() + '" ' +
                   'id="candidate_' +  theCandidate + '">' +
                   '<label><input type="checkbox" value="" id="coalition_' +  theCandidate + '"></label>'+
                   '<label for="name' + theCandidate + '">&nbsp;&nbsp;Party ' + parties[contest].length +  ' Name: </label> ' +
                   '<input class="form-control" type="text" value= "Party'+parties[contest].length.toString()+'" size="40" id="name' + theCandidate + '" onblur="names[' + contest + '][' +
                      (parties[contest].length-1) + ']=this.value;" />' +
                   '<label for="nSeats' + theCandidate + '">&nbsp;&nbsp;Seats: ' + '</label>' +
                   '<input class="form-control" type="number" min="0" value="0" id="nSeats' + theCandidate + '" onblur="updateVotes()"/></div></form>');
        }

        /*Function to build the overall input table for votes for parties in every constituency
        No Parameters
        Return type: boolean*/
        function buildOverallMat() {
            nCandidates = parseInt($("#nCandi").val());
            nConstituencies = parseInt($("#nSeats").val());
            var str = '<div class="panel panel-default" id="candidateStatistic" >' +
                        '<div class="panel-heading">Vote Tally</div>'+
                        '<div class="panel-body"><div>'+
                      '<table class="table table-striped table-bordered" id="overallMat"><thead></thead><tbody></tbody></table></div>';
            $(".overallTable").empty();
            $(".overallTable").append(str);

            str = '';
            str += '<tr><th></th>';
            for (var W=0; W < nCandidates; W++) {
                    str += '<th class="text-left success" id="Tcandidate_' + 0 + '_' + W + '">' + names[0][W] +
                            '&nbsp;</th>';
                }
            $("#candidateStatistic thead").append(str);

            str='';
            for (var i=0; i < nConstituencies; i++) {
                str += '</tr>';
                str += '<tr id="Tconsti_'  + i + '"><td class="info">' + 'constituency ' + (i+1) +
                       '&nbsp;</td>';
                for (var W=0; W < nCandidates; W++) {
                    str += '<td class="text-left"><input type="number" id="votes_for_' + i + '_' + W +
                       '" value="0" /></td>';
                }
                str += '</tr>';
            }
            //console.log("Tally");
            //console.log(str);
            $("#candidateStatistic tbody").empty();
            $("#candidateStatistic tbody").append(str);
            //$("#candidateStatistic td").css('backgroundColor', '#fff');
            //$(".candidateRow").css('backgroundColor', '#fff');
            //$(".candidateSpinner").spinner({min: 0});
            //$(".constiSpinner").spinner({min: 0});
            /*for (var i=0; i< parties.length; i++) {
                $("[id^=votes_for_" + i + "]").change(
                   (function(x){ return function(){updateTestStatistic(x);}})(i));
                
            }*/
            //$('.ui-spinner-button').click(function() {$(this).siblings('input').change();});
            
            return(true);
        }

        /*Auxiliary helping function which reads in the votes for parties from HTML input into a 2D array
        No Parameters
        Return value: true*/
        function getData(){
            var dataArray = [];
            for (var i=0; i < nConstituencies; i++) {
                dataArray[i]=[];
                for (var W=0; W < nCandidates; W++) {
                    dataArray[i][W]=parseInt($("#votes_for_" + i + "_" + W).val());                    
                }
                
            }
            //console.log(dataArray);
            return true;
        }

        /*Function called whenever "Compute" is clicked
        No Parameters
        Creates the table showing the various risks for every constituency*/
        function findRisks(){
            var riskArray = findOverRisks();
            if(riskArray.length==0) 
                return false;
            //console.log(riskArray);

            //Building the UI
            var str='';
            str = '<div class="table-responsive"><table class="table table-bordered table-striped" id="riskMat"><thead></thead><tbody></tbody></table></div>';
            //$(".riskMat").empty();
            //$("#riskStatistic tbody").empty();
            $(".newRisks").empty();
            $(".newRisks").append(str);
            str = '';
            str+='<tr>';
            
            for(var i=0; i<nConstituencies; i++){
                str+='<th class="candidateRow text-left">'+ "Constituency " + (i+1) +'</th>';
            }
            str+='</tr>';
            $("#riskMat thead").append(str);
            //$(".newRisks").append(str);

            str='';
            str+='<tr>';

            for(var i=0; i<nConstituencies; i++){
                str+='<td class="text-left">'+ roundToDig(riskArray[i], 2) + '</td>';
            }
            
            /*
            //Organising the risk table as 5 per row
            for (var i=0; i<nConstituencies; i+=5){
                for(var j=i; j<nConstituencies && j<i+5; j++){
                    str+='<th class="candidateRow">'+ "Constituency" + (j+1) +'</th> &nbsp; &nbsp';
                }
                str+='</tr><tr class="active">';
                for(j=i; j<nConstituencies && j<i+5; j++){
                    str+='<td>'+ roundToDig(riskArray[j], 2) + '</td>';
                }
            }*/
            str+='</tr>';
            $("#riskMat tbody").append(str);

            //$("#riskStatistic td").css('backgroundColor', '#eee');
            //$(".newRisks").append(str);
        }

        /*Function to convert the votes for every constituency into percentages for the parties
        No parameters
        Return Value: 2D array storing the percentages of votes for parties in every constituency*/
        function convToPerc(){
            var percArray = [];
            var dataArray = [];
            var sumArray = new Array(nConstituencies).fill(0);
            
            for (var i=0; i < nConstituencies; i++) {
                dataArray[i]=[];
                for (var W=0; W < nCandidates; W++) {
                    dataArray[i][W]=parseInt($("#votes_for_" + i + "_" + W).val());    
                    sumArray[i]+=parseInt($("#votes_for_" + i + "_" + W).val());                 
                }
            }
            //console.log(sumArray);
            for(var i=0; i<nConstituencies; i++){
                percArray[i]=[];
                for (var W=0; W < nCandidates; W++) {
                    percArray[i][W]=dataArray[i][W]/sumArray[i];
                }
            }
            //console.log(percArray);
            return percArray;
        }

        /*Function to find the diluted margin in every constituency
        No Parameters
        Return value: 1D array storing the diluted margins*/
        function findMargins(){
            var percArray =convToPerc();
            var margArray = new Array(parseInt($("#nSeats").val()));
            var sortedArray = [];

            for(var i=0; i<nConstituencies; i++){
                sortedArray = percArray[i].slice().sort(numberLessThan).reverse();
                margArray[i]=sortedArray[0]-sortedArray[1];
            }
            //console.log(margArray);
            return margArray;
        }

        /*Function to find the winners in every constituency
        No Parameters
        Return Value: 1D array storing Winning Party number in every constituency*/
        function findWinners(){
            var percArray =convToPerc();
            var winArray = new Array(nConstituencies);
            var maxIdx; //temporary variable to store the winner's index

            for(var i=0; i<nConstituencies; i++){
                maxIdx = 0;
                for(var j=1; j<nCandidates; j++){
                    if(percArray[i][j]>percArray[i][maxIdx])
                        maxIdx = j;
                }
                winArray[i]=maxIdx;
            }
            //console.log(winArray);
            return winArray;
        }

        /*Function to find the number of seats that every party has secured in the overall results
        No parameters
        Return value: 1D array storing the number of seats secures by every party*/
        function findSeats(){
            var winArray =findWinners();
            var seats = new Array(nCandidates).fill(0);
            var winner=0;

            for(var i=0; i<winArray.length; i++){
                seats[winArray[i]]++;
            }
            return seats;
        }

        /*Function to find the overall winner of the elections
        No parameters
        Return value: Winning party number*/
        function findOverWin(){
            var winArray =findWinners();
            var seats =findSeats();
            var winner = 0;

            for(var i=1; i<seats.length; i++){
                if(seats[i]>seats[winner])
                    winner=i;
            }
            //console.log(winner);
            return winner;
        }

        /*Function to find the difference b/w minimal flipset containing party p if any
        and the toppling margin
        Parameters:
        p: The party number for which to find the toppling margin
        Return value: Toppling margin in case party p can exist in a minimal flipset, else -1*/
        function findTopMarg(p){
            var seats =findSeats();
            var curSeats = seats[p];
            var Q = new Array();
            var minSeats = Math.ceil(nConstituencies/2.0);
            var a, b, c, flag=0;

            if(p>-1)
                seats.splice(p, 1); //Removing the particular party from the array
    
            seats.sort(numberLessThan); //increasing order
            //console.log(seats);
            for(var i=0; i<seats.length; i++){
                Q[i] = new Array();
            }

            for(var s=0; s<minSeats; s++){
                Q[0][s]=0;
            }

            for(var s=0; s<minSeats; s++){
                for(var i=1; i<seats.length; i++){
        
                    if(i>0)
                        a = Q[i-1][s];
                    else
                        a=0;

                    if(seats[i]==s)
                        b = 1;
                    else
                        b = 0;

                    if(i>0 && seats[i]<s)
                        c = Q[i-1][s-seats[i]];
                    else
                        c=0;
                    
                    if(a==1 || b==1 || c==1){
                        Q[i][s] = 1;
                        if(s>=minSeats-curSeats){
                            flag=1;
                            break;
                        }
                    }
                    else
                        Q[i][s] = 0;
                }
            }
            //console.log(Q);
            if(flag==1){
                return (s+curSeats-(minSeats-1));
            }
            else
                return -1;
        }

/*Function which finds the coalition of the selected parties
No Parameters
Returns an array storing the indices of the parties in the coalition*/
        function findCoalition(){
            var coalition = new Array();
            var check;
            for (var i=0; i < parties.length; i++) {
                for (var j=0; j < parties[i].length; j++) {  // set colors; build winner and loser lists
                        var theCandidate = (i+1).toString() + '_' + (j+1).toString();
                        check = document.getElementById('coalition_' + theCandidate);
                        if(check.checked){
                            coalition.push(j);
                        }
                }
            }
            return coalition;
        }

/*Function to find the toppling margin = votes for coalition-half of seats
No parameters
Returns toppling margin if coalition is successfull, else -1*/
        function findToppleMargin(){
            var coalition =findCoalition();
            var sum=0;
            var seats =findSeats();
            //console.log(coalition);
            try{
                for (var i=0; i < coalition.length; i++) {
                    sum+=seats[coalition[i]];
                }
                if(sum>=Math.floor(nConstituencies/2)+1)
                    return (sum-Math.floor(nConstituencies/2));
                else
                    throw'Not sufficient seats in coalition to form government';
            }
            catch(e){
                alert(e);
            }
            return -1;
        }

/*Function which determines if party p is present in the coalition*/
        function inCoalition(p){
            var coalition =findCoalition();
            for(var i=0; i<coalition.length; i++){
                if(coalition[i]==p)
                    return true;
            }
            return false;
        }

        /*Function to find the diluted margins in constituencies wherer the winning party was elected
        No Parameters
        Return value: 1D array storing the diluted margins*/
        function findWinMarg(){
            var margArray =findMargins();
            var winArray =findWinners();
            var winner = findOverWin();
            var coalition = findCoalition();
            var winMargArray = [];
            
            for(var i=0; i<nConstituencies; i++){
                if (inCoalition(winArray[i]))
                    winMargArray.push(margArray[i]);
            }
            //console.log(winMargArray);
            return winMargArray;
        }

        /*Auxilliary function to find the expected factor for the number of votes in auditing 
        a particular subset of constituencies where the winner has won.
        Parameters: Index of constiteuncy after which constituencies are only audited (when
        sorted in non-decreasing order of diluted margins)
        Return value: Expected factor*/
        function findExpec(idx){
            var coalition =findCoalition();
            var winMargArray = findWinMarg();
            winMargArray.sort(numberLessThan); //Non-decresaing order
            //console.log(winMargArray);
            var toppleMargin = findToppleMargin();
            //console.log(toppleMargin);
            var sum=0.0;

            for(var j=idx; j<winMargArray.length; j++){
                    sum+=1.0/winMargArray[j];
                }
            //console.log(sum);
            sum*=1.0/(toppleMargin-idx);
            //console.log(sum);
            return sum;
        }

        /*Main auxilliary function to find the risks upto which the constituencies should be audited
        No Parameters
        Return value: 1D array storing the risks*/
        function findOverRisks(){
            var margArray =findMargins();
            var winArray = findWinners();
            var winner = findOverWin();
            var toppleMargin; //= findToppleMargin();
            var winMargArray =findWinMarg();
            var coalition =findCoalition();
            var risk = parsePercent($("#risk").val());
            var minIdx=0, minMargin;
            var riskArray = []; //Stores the risk limit for every constituency      
            //console.log(toppleMargin);            
            //console.log(winMargArray);
        
            /*for(var j=0; j<nCandidates; j++){
                toppleMargin = findToppleMargin(j);
                console.log(toppleMargin);
                
                for(var k=0; k<nConstituencies; k++){
                    if(winner[k]==j)
                        if(toppleMargin!=-1)
                            riskArray[k]=Math.pow(risk, 1.0/(toppleMargin));
                        else
                            riskArray[k]=0;
                }*/
                toppleMargin =findToppleMargin();
                if(toppleMargin==-1){
                    return riskArray;
                }
                for(var i=1; i<toppleMargin; i++){
                    if(findExpec(minIdx)>findExpec(i))
                        minIdx = i;
                }

                //console.log(minIdx);
                winMargArray.sort(numberLessThan); //Non-decereasing order
                minMargin = winMargArray[minIdx];
                
                var exp = 1.0/(toppleMargin-minIdx);
                //console.log(exp);
                //console.log(minMargin);
                for(i=0; i<nConstituencies; i++){
                    if(inCoalition(winArray[i])){ //If not a winner's constituency, no need to audit
                        if(margArray[i]<minMargin) //If diluted margin in winner's constituency is more
                                                    //than the prescribed upper limit, no need to audit
                            riskArray[i]=0;
                        else //If diluted margin within the desired upper bound
                            riskArray[i]=Math.pow(risk, 1.0/(toppleMargin-minIdx));
                    }
                    else{
                        riskArray[i]=0;   
                    }
                }
            //}
            //console.log(riskArray);
            return riskArray;
        }

        /*function buildTestMatrix() { //not needed
               Builds the matrix of test statistics and populates the Wald factor matrix.
                Assumes that winners[] and losers[] have been populated.
            
            var str = '<div class="testStatistic" id="testStatistic" >' +
                      '<table id="testMatrix"><tbody></tbody></table></div>';
            $(".testTable").empty();
            $(".testTable").append(str);
            str = '';
            for (var i=0; i < parties.length; i++) {
                str += '<tr><th class="voteRow" colspan="' + (winners[i].length+1) +
                       '" id="sizeSoFar_' + i + '">Audited votes for ' + $("#contestName" + i).val() +
                       ': 0</span></th></tr>' +
                       '<tr><th></th>';
                for (var W=0; W < winners[i].length; W++) {
                    str += '<th id="Twinner_' + i + '_' + winners[i][W] + '">' + names[i][winners[i][W]] +
                            '&nbsp;<input type="text" class="voteSpinner" id="votes_for_' + i + '_' + winners[i][W] +
                            '" value="0" /></th>';
                }
                str += '</tr>';
                for (var L=0; L < losers[i].length; L++) {
                    str += '<tr id="Tloser_'  + i + '_' + losers[i][L] + '"><th>' + names[i][losers[i][L]] +
                           '&nbsp;<input type="text" class="voteSpinner" id="votes_for_' + i + '_' + losers[i][L] +
                           '" value="0" /></th>';
                    for (var W=0; W < winners[i].length; W++) {
                        str += '<td id="T_' + [i, losers[i][L], winners[i][W]].join('_') + '">1</td>';
                    }
                    str += '</tr>';
                }
            }
            //console.log(str);
            $("#testStatistic tbody").append(str);
            $("#testStatistic td").css('backgroundColor', '#E55');
            $(".voteRow").css('backgroundColor', '#999');
            $(".voteSpinner").spinner({min: 0});
            for (var i=0; i< parties.length; i++) {
                $("[id^=votes_for_" + i + "]").change(
                   (function(x){ return function(){updateTestStatistic(x);}})(i));
            }
            $('.ui-spinner-button').click(function() {$(this).siblings('input').change();});
            lastWinner=firstLoser=0;
            // populate the Wald factor matrix
            waldFactor = [];
            for (var i=0; i < parties.length; i++) {
                waldFactor.push({});
                for (var W=0; W < winners[i].length; W++) {
                    for (var L=0; L < losers[i].length; L++) {
                        hashString = winners[i][W] + ',' + losers[i][L];
                        waldFactor[i][hashString] = parties[i][winners[i][W]] /
                                         (parties[i][winners[i][W]] + parties[i][losers[i][L]]);
                    }
                }
            }
            var dum = parties[0].slice().sort(numberLessThan).reverse();
            wf1 = 2.0*dum[0]/(dum[0]+dum[1]);
            wf2 = 2.0*(ballots-dum[0])/(2.0*ballots-dum[0]-dum[1]);

            return(true);
        }*/
        
/*Function to test the progress of the audit
Parameters: Contest i which in our case is 0 always
No return value*/
        function updateTestStatistic(i) { // needed updates the test statistic for contest i
            risk = parsePercent($("#risk").val());
            var totVotes = totWinVotes = totLosVotes = 0;
            for (var W=0; W < winners[i].length; W++) {
                vW = parseInt($("#votes_for_" + i + '_' + winners[i][W]).spinner('value'));
                totVotes += vW;
                totWinVotes += vW;
                for (var L=0; L < losers[i].length; L++) {
                    vL = parseInt($("#votes_for_" + i + '_' + losers[i][L]).spinner('value'));
                    totVotes += vL;
                    totLosVotes += vL;
                }
            }
            ts = 1.0/(Math.pow(wf1, totWinVotes) * Math.pow(wf2, totLosVotes));
            $("#T_" + [0, losers[0][0], winners[0][0]].join('_')).text(roundToDig(ts, 2));
                if (ts <= risk) {
                    $("#T_" + [0, losers[0][0], winners[0][0]].join('_')).css('backgroundColor', '#5E5');
                } else {
                    $("#T_" + [0, losers[0][0], winners[0][0]].join('_')).css('backgroundColor', '#E55');
                }
            $("#sizeSoFar_" + i).text("Audited votes for " + $("#contestName" + i).val() + ": " + commify(totVotes));
        }/*
        var hasher;
        var sample = new Array(3);
        sample[0] = new Array();
        sample[1] = new Array();
        sample[2] = new Array();
        function hashMe() {  // hashes the next sequence number
            hasher = new jsSHA($("#seedValue").val() + "," +
                               $("#samNum").val(), "ASCII");
            $("#nObj").val(parseInt($("#nObj").val()));
            if ($("#nObj").val() == 'NaN') {
                $("#nObj").val(1);
            }
            try {
                sample[0].push($("#samNum").val());
                sample[1].push(hasher.getHash("SHA-256", "HEX"));
                sample[2].push(1 +
                                 modInt( str2bigInt(hasher.getHash("SHA-256", "HEX"), 16, 0),
                                          parseInt($("#nObj").val())
                                       )
                               );
                writeList();
                $("#sortedList").val(sample[2].slice().sort(numberLessThan).join(','));
                $("#ballotList").val($("#sortedList").val());
                var deDupeList = sortMultiple(sample[2], numberLessThan);
                $("#sortedDedupeList").val(deDupeList[0].join(','));
                if (vMinMax(deDupeList[1])[1] > 1) {
                     $("#duplicates").val('Ballot, multiplicity\n' + arrayToString(findRepeats(deDupeList)));
                }
            } catch(e) {
            }
        }
        function writeList() {  // writes the list of ballots selected
            if ($("#showSequence").prop('checked') &
                   $("#showHash").prop('checked') ) {
                $("#list").val('sequence_number, hash value, ballot\n' + arrayToString(sample));
            } else if ($("#showSequence").prop('checked')) {
                $("#list").val('sequence_number, ballot\n' + arrayToString([sample[0],sample[2]]));
            } else if ($("#showHash").prop('checked')) {
                $("#list").val('hash, ballot\n' + arrayToString([sample[1],sample[2]]));
            } else {
                $("#list").val(sample[2].join(','));
            }
            return(true);
        }*/

/*Initialization function
No Parameters
No return value*/
        function startMe() {
            clearList();
            //hashMe();
        }

/*Function to clear the lists created
No Parameters
No return value*/        
        function clearList() {  // clear the lists not needed
            sample = new Array(3);
            sample[0] = new Array();
            sample[1] = new Array();
            sample[2] = new Array();
            $("#list").val('');
            $("#sortedList").val('');
            $("#sortedDedupeList").val('');
            $("#ballotList").val('');
            $("#duplicates").val('');
            if(findMinMargin()) {
                //buildTestMatrix();
                buildOverallMat();
            }
        }

/*Reset function to reset everything to defaults
No Parameters
No return value*/
        function resetMe() {  // reset
            clearList();
            $("#samNum").val('0');
        }
        
        /*function nextSample() {  // not needed
            for (var i=0; i < parseInt($("#samMany").val()); i++) {
                $("#samNum").val(parseInt($("#samNum").val()) + 1);
                hashMe();
            }
        }*/

/*Function which segregatest the candidates into winners and losers and also computes
the Average Sample Number (ASN) of votes
No Parameters
Returns whether there are sufficient candidates & Min Margin is calculated &
sum of votes for candidates doesn't exceed total number of votes*/
    function findMinMargin() { //needed
        ballots = parseInt($("#nSeats").val());
        nCandidates = parseInt($("#nCandi").val());
        nConstituencies = parseInt($("#nSeats").val());
        if (parties.length > 0) {
               minMargin = ballots;
        } else {
            minMargin = Number.NaN;
        }
        var ballOk = !isNaN(ballots);
        var opsOk = true;
        var votesOk = true;
        var asn = Number.NaN;
        var newRisk = Number.NaN;
        var percArray = [[]];
        percArray =convToPerc();

        //Rading candidate votes into candidate[] array
        try {
            asn = 0;
            for (var i=0; i < parties.length; i++) {
                var cani = 1; //Number of winners
                if (parties[i].length < cani ) { // not enough parties
                    opsOk = false;
                }
                for (var j=0; j < parties[i].length; j++) {
                    parties[i][j] = parseInt($("#nSeats" + (i+1).toString() + '_' + (j+1).toString()).val());
                }
                if (vSum(parties[i]) > cani*ballots) { // too many votes
                    votesOk = false;
                }

                //Splitting the group into winners and losers
                var dum = parties[i].slice().sort(numberLessThan).reverse(); //duplicates and sorts
                minMargin = Math.min(minMargin, dum[cani-1] - dum[cani]);
                winners[i] = [];
                losers[i] = [];
                for (var j=0; j < parties[i].length; j++) {  // set colors; build winner and loser lists
                    var theCandidate = (i+1).toString() + '_' + (j+1).toString();
                    if (parties[i][j] > dum[cani]) {
                        $("#candidate_" + theCandidate).css('backgroundColor', '#5e5');
                        winners[i].push(j);
                    } else {
                        $("#candidate_" + theCandidate).css('backgroundColor', '');
                        losers[i].push(j);
                    }
                }
                /* risk limit has been set; we can calculate sample size if all margins are
                      defined.*/
                if (parsePercent($("#risk").val())) {                   
                    asn = Math.max(asn, findAsn(ballots,
                              dum[cani-1],
                              dum[cani]));
                    newRisk = Math.pow(risk, 1.0/(minMargin/2));
                } 
            }
        } 
        
        //Catching and reporting exceptions 
        //Reseting values in case of error
        catch(e) {
           minMargin = 'undefined';
           asn = 'undefined';
           newRisk = 'undefined';
           alert(e);
        }
        if (!opsOk | isNaN(minMargin)) {
            minMargin = 'undefined';
            asn = 'undefined';
            newRisk = 'undefined';
            $("#theDilutedMargin").text('Diluted margin: undefined.');
            $("#theMargin").text('Smallest margin (votes): undefined.');
            $("#asn").text('Expected sample size: undefined.');
            $("#newRisk").text("New Risk limit for winner's constituencies: undefined.");
        } 
        //If there are sufficient candidates and min Margin is calculated successfully 
        else {
            $("#theMargin").text('Smallest margin (votes): ' + commify(minMargin) + '. ');
            $("#theDilutedMargin").text(' Diluted margin: ' + commify(doubleToStr(100*minMargin/ballots,2)) + '%. ');
            $("#asn").text('Expected sample size: ' + commify(asn) + '. ');
            $("#newRisk").text("New Risk limit for winner's constituencies: " + commify(newRisk) + '. ');
            //buildTestMatrix();
            buildOverallMat();
        }
        if (!(opsOk & votesOk & ballOk)) {
            try {
                for (var i=0; i < parties.length; i++) {
                    var vf = 1;
                /*    if (parties[i].length <  vf ) {
                        throw 'Fewer parties than voting opportunities in contest ' + (i+1).toString() + '!';
                    }*/
                    if (vSum(parties[i]) > vf*ballots) {
                        throw 'More votes than voting opportunities in contest ' + (i+1).toString() + '!';
                    }
                }
            } catch(e) {
                alert(e);
            }
        }
        return(opsOk & votesOk & ballOk);
    }

/* returns Wald's "average sample number" (ASN)
Refer Mohanty Vanessa et. al. for the ASN formula*/
    function findAsn(ballots, vw, vl) {  // not needed returns Wald's "average sample number" (ASN)
        /* ballots = total ballots in the contest
           vw = ballots cast for the winner of the pair
           vl = ballots cast for the loser of the pair
        */
        try {
            risk = parsePercent($("#risk").val());
            if (vw > vl) {
                pw = vw/ballots;
                pl = vl/ballots;
                zw = Math.log(2.0*pw/(pw+pl));
                zl = Math.log(2.0*(1-pw)/(2.0-pw-pl));
                asn = Math.ceil(
                     (Math.log(1.0/risk))/(pw*zw + (1-pw)*zl));
            } else {
                asn = 'undefined';
            }
        } catch(e) {
            asn = 'undefined';
        }
        return(asn);
    }

/*Function called when the risk value is changed
No Parameters
Returns true upon successfull execution*/
    function updateRisk(){    
        try{
            risk = parsePercent($("#risk").val());
            if(risk>1 || risk<0)
                throw 'Risk percentage should be between 0% and 100% only';
        }
        catch(e){
            $("#risk").val("10%");
            risk = parsePercent($("#risk").val());
            alert(e);
        }
        return true;
    }

/*Function called when the number of votes are updated*/
    function updateVotes() { 
        clearSampleSizes();
        findMinMargin();
        return(true);
    }

/*Function to clear the sample sizes*/
    function clearSampleSizes() { //needed
        $('#startSampleSize').html('&hellip;');
        if (findMinMargin()) {
            //buildTestMatrix();
            buildOverallMat();
            $(".newRisks").empty();
        }
        return(true);
    }


    /*function lookUpBallots(whichBallots, sort) { //not needed
        for (var i=0; i < whichBallots.length; i++) {
           whichBallots[i] = parseInt(whichBallots[i]);  // the ballots to find
        }
        if (parseManifest()) {
           if (vSum(manifest[1]) != $("#nObj").val()) {
                alert('Error: Number of ballots in the manifest, ' + vSum(manifest[1]).toString() +
                      ' is not equal to the number of ballots in the contest, ' + $("#nObj").val() +'!');
                return(Number.NaN);
            } else if (vMinMax(whichBallots)[1] > vSum(manifest[1])) {
                alert('Error: Requested ballot exceeds the number of ballots in the manifest!');
                return(Number.NaN);
            } else if (vMinMax(whichBallots)[0] < 1) {
                alert('Error: Requested ballot number is negative!');
                return(Number.NaN);
            }
            var manCum = new Array(manifest[0].length);  // cumulative number of ballots in batches
            manCum[0] = 0;
            for (var i=1; i < manifest[0].length; i++) {
               manCum[i] = manCum[i-1] + manifest[1][i-1];
            }
            var lookUp = new Array(3); // ballot (absolute numbering), batch, identifier_in_batch
            lookUp[0] = whichBallots;
            lookUp[1] = new Array(whichBallots.length);
            lookUp[2] = new Array(whichBallots.length);
            for (var i = 0; i < whichBallots.length; i++) {
                var j = 0;
                while (manCum[j] < whichBallots[i]) {
                    j++;
                }
                j--;
                lookUp[1][i] = manifest[0][j];
                if (typeof(manifest[2][j]) == 'object') {
                    lookUp[2][i] = manifest[2][j][whichBallots[i] - manCum[j] - 1];
                } else {
                    lookUp[2][i] = whichBallots[i] - manCum[j] + manifest[2][j] - 1;
                }
            }
            var str = 'sorted_number, ballot, batch_label, which_ballot_in_batch\n';
            for (var i=0; i < lookUp[0].length; i++ ) {
                str += (i+1).toString() + ', ' + lookUp[0][i].toString() + ', ' +
                       lookUp[1][i].toString() + ', ' + lookUp[2][i].toString() + '\n';
            }
        } else {
            str = 'The manifest cannot be parsed.\n' +
                  'Be sure that the each line of the manifest consists of a batch ' +
                  'label followed by a comma and a number or ' +
                  'a colon-separated ballot range or a list of identifiers in parentheses. ' +
                  'There must be exactly one comma per line.\n';
            $("#manifest").val(str + $("#manifest").val());
        }
        $("#lookUp").val(str);
    }
var manifest = null;
    function parseManifest() { //not needed
        var stuff = $("#manifest").val().replace(/\n+/gi,'\n').split('\n');
        var grabBagRegExp = /^ *\(.+\) *$/i
        var batches = new Array(3);
        batches[0] = new Array();  // batch labels
        batches[1] = new Array();  // number of ballots in the batch
        batches[2] = new Array();  // number of the first ballot in the batch, or an array of identifiers
        success = true;
        var j = 0;
        for (var i=0; i < stuff.length; i++) {
            if (typeof(stuff[i]) == 'undefined' || stuff[i] == null || stuff[i] == '') {
               continue;
            } else if (stuff[i].indexOf(',') < 0) {
               alert('Error! Line ' + (i+1).toString() + ' of the manifest has no commas: ' +
                      stuff[i].toString());
               success = false;
            }  else {
               var dum = stuff[i].split(',');
               if (dum.length != 2) {
                   alert('Error! Line ' + (i+1).toString() + ' of the manifest does not parse: ' +
                         stuff[i].toString() +
                         ' Be sure it has exactly one comma, separating the label from the ' +
                         'number of ballots or the ballot range.' );
                   success = false;
               } else {
                   batches[0][j] = dum[0];
                   if (dum[1].indexOf(':') >=  0) {
                         var mRange = dum[1].split(':');
                         batches[1][j] = parseInt(mRange[1]) - parseInt(mRange[0]) + 1;
                         batches[2][j] = parseInt(mRange[0]);
                   } else if (grabBagRegExp.test(dum[1])) {
                         batches[2][j] = new Array();
                         batches[2][j] = dum[1].replace(/( *\( *| *\) *)/g,'').replace(/ +/g,' ').split(' ');
                         batches[1][j] = batches[2][j].length;
                   } else {
                         batches[1][j] = parseInt(dum[1]);
                         batches[2][j] = 1;
                   }
                   j++;
               }
            }
        }
        if (success) {
            manifest = batches;
        } else {
            manifest = null;
        }
        return(success);
    }*/
//  General-purpose utilities
        function numberLessThan(a,b) { // numerical ordering for javascript sort function
            var diff = parseFloat(a)-parseFloat(b);
            if (diff < 0) {
                return(-1);
            } else if (diff == 0) {
               return(0);
            } else {
               return(1);
            }
         }
        function sortMultiple(list,order) { // sort a list, tabulate multiplicity of items. list is unchanged
            var ans = null;
            if (list.length > 0) {
                var temp = list.slice();
                if (typeof(order) != 'undefined' && order != null) {
                   temp.sort(order);
                } else {
                   temp.sort();
                }
                ans = new Array(2);
                ans[0] = new Array();
                ans[1] = new Array();
                ans[0][0] = temp[0];
                ans[1][0] = 1;
                for (var i=1; i < temp.length; i++) {
                   if (temp[i] == ans[0].slice(-1)) {
                       ans[1][ans[1].length-1]++;
                   } else {
                       ans[0].push(temp[i]);
                       ans[1].push(1);
                   }
                }
            }
            return(ans);
        }
        function findRepeats(list) { // find elements with multiplicity greater than one
                                     // in an array generated by sortMultiple()
            var ans = new Array(2);
            ans[0] = new Array();
            ans[1] = new Array();
            for (var i = 0; i < list[0].length; i++) {
                if (list[1][i] > 1) {
                   ans[0].push(list[0][i]);
                   ans[1].push(list[1][i]);
                }
            }
            return(ans);
        }
        function arrayToString(arr) { // formats an array
            var str = '';
            var cols = arr.length;
            var rows = arr[0].length;
            for (var j=0; j < rows; j++) {
                for (var i=0; i < cols; i++) {
                    str+= arr[i][j] + ',';
                }
                str = str.replace(/,$/,'\n');
            }
            return(str);
        }
    function vCum(list) { // vector of cumulative sum
        var list2 = list;
        for (var i = 1; i < list.length; i++ ) {
            list2[i] += list2[i-1];
        }
        return(list2);
    }
    function vMinMax(list){ // returns min and max of list
        var mn;
        var mx;
        if (list.length == 'undefined' || list.length == 0) {
           mn = list;
           mx = list;
        } else {
           mn = list[0];
           mx = list[0];
           for (var i=1; i < list.length; i++) {
               if (mn > list[i]) mn = list[i];
               if (mx < list[i]) mx = list[i];
           }
        }
        var vmnmx =  new Array(mn,mx);
        return(vmnmx);
    }
    function vSum(list) { // computes the sum of the elements of list
        var tot = 0.0;
        for (var i = 0; i < list.length; i++) {
            tot += list[i];
        }
        return(tot);
    }
    function removeAllBlanks(s){
        return(s.replace(/ +/gm,''));
    }
    function commify(num) { // punctuate number strings greater than 1,000 in magnitude
        var str;
        var strA = (removeAllBlanks(num.toString())).toLowerCase();
        if ( (strA.indexOf('e') > -1) || (strA.indexOf('d') > -1) ) {
            str = strA;  // don't mess with exponential notation
        } else {
            str = strA;
            var curLoc = str.length;
            if ( str.indexOf('.') > -1 ) {
                curLoc = str.indexOf('.');
            }
            var negSign = str.indexOf('-');
            for (var loc = curLoc-4; loc > negSign; loc -= 3) {
                str = str.substr(0,loc+1) + ',' + str.substr(loc+1, str.length);
            }
        }
        return(str);
    }
    function parsePercent(s) {
    // parse a number that contains a % sign to turn it into a decimal fraction
        var value;
        if (s.indexOf('%') == -1) {
            value = parseFloat(trimBlanks(removeCommas(s)))
        } else {
            while (s.indexOf('%') != -1) {
                s = s.substring(0,s.indexOf('%')) +
                    s.substring(s.indexOf('%')+1,s.length)
            }
            value = parseFloat(trimBlanks(removeCommas(s)))/100;
        }
        return(value);
    }
    function roundToDig(num, dig) { // rounds a number or list to dig digits after the decimal place
        var powOfTen = Math.pow(10,dig);
        if ((typeof(num)).toLowerCase() == 'number') {
            var fmt = Math.round(num*powOfTen)/powOfTen;
            return(fmt);
        } else if ((typeof(num)).toLowerCase() == 'object' ||
                   (typeof(num)).toLowerCase() == 'array') {
            var fmt = new Array(num.length);
            for (var i = 0; i < num.length; i++) {
                fmt[i] = Math.round(num[i]*powOfTen)/powOfTen;
            }
            return(fmt);
        } else {
            alert('Error #1 in roundToDig(): argument (' + num.toString() + ') is not a number or an array');
            return(Math.NaN);
        }
    }
    function doubleToStr(num,dig) {
      // returns a string representation of num, rounded to dig digits after the decimal
        return(removeAllBlanks(roundToDig(num,dig).toString()));
    }
    function removeCommas(s) { // removes commas from a string
        return(s.replace(/,/gm,''));
    }
    function trimBlanks(s) { // remove leading and trailing spaces
        s = s.replace(/^ +/gm,'');
        s = s.replace(/ +$/gm,'');
        return(s);
    }
// -->
</script>

<title>Efficient Auditing of Indian Elections</title>

</head>

<body onload="startMe();resetMe();">

</head>
<div id="bodyDiv">
<nav class="navbar navbar-inverse">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <!--div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#">Home</a>
    </div-->

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
        <ul class="nav navbar-nav">
            <li><a href="overall.html">Home</a>
        </ul>
        <ul class="nav navbar-nav">
        <li><a href="simpleBP1.html">Simple Ballot Polling Audit<span class="sr-only">(current)</span></a></li>
        </ul>
        <ul class="nav navbar-nav">
        <li><a href="https://www.stat.berkeley.edu/~stark/Vote/auditTools.htm">Stark's Ballot Comparison Audit</a></li></ul>
        <ul class="nav navbar-nav">
        <li><a href="https://www.stat.berkeley.edu/~stark/Vote/ballotPollTools.htm">Stark's Ballot Polling Audit</a></li></ul>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="developersOverall.html">Developers</a></li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>
<h1>
<center>Efficient Auditing of Indian Elections</center>
</h1>

<ul class="nav nav-tabs" role="tablist">
    <li role="presentation" class="active"><a href="#theory" aria-controls="theory" role="tab" data-toggle="tab">Theory</a></li>
    <li role="presentation"><a href="#technical" aria-controls="technical" role="tab" data-toggle="tab">Technical Notes</a></li>
</ul>

<!-- Tab panes -->
<div class="tab-content">
    <div role="tabpanel" class="tab-pane active" id="theory">
<p>
   This Page implements the tools for finding out the <b>Risk Limits</b> for auditing of multi-level
   elections as is the case in India. It features a one-time contest for electing a single Party or Coalition 
   to power in the Central Government.
</p>

<p id="hideAll">
  To hide or show everything but the tools <button type="button" class="btn btn-default" id="hideAllProse">Click Here</button>
</p>

<p>
<div class="panel panel-primary">
  <div class="panel-heading">Theory</div>
  <div class="panel-body">
<p>
   A <b>Risk-Limiting Audit</b>, also sometimes referred to as the Result-Conforming Audit
   is a method of post-election audit designed to confirm the election results by examining a small sample of
    the votes. The <b>Risk Limit</b> is the maximum probability that the audit will not detect
    any error in election result when it is present. The error here refers to the case when the
    candidate/party declared as the winner in a given constituency is not the actual winner who
    would be reported by a full-hand manual count of the votes. 
</p>

<p>
  There are quite a many tools for performing risk-limiting audit, the prominent of them being the
  Ballot Polling Audit. Tools for performing that is present in Vanessa's webpage titled
  <b>Simple Ballot Polling Audit</b>. You could alternatively use Stark's Ballot Polling tools at 
  <b>Stark's Ballot Polling Audit</b>.
</p>

<p>
   Multi-level elections can be efficiently audited. The desired confidence level in the overall 
   elections can be shared by individual constituencies. The product of the risk limits in the 
   individual constituencies results in the overall risk limit. When a coalition wins the elections,
   auditing is done in those constituencies where the parties belonging to that particular 
   coalition has won. The sharing of the risk limits is done assuming that the election outcome
   is correct in the audited constituencies. If during the audit the result in any constituency
   does change, then the risk limits to which the other constituencies have been audited must be
   changed. This will require auditing more number of votes in those constituencies. 
   The new risk-limits will be reflected in the tools developed by us by simply feeding in
   new election results for that particular constituency.
</p>

<p>
    The tools on this page work as follows:
</p>

<ul>
   <li>Choose the number of constituencies in the overall elections (In India, for eg. 543)</li>
   <li>Select the number of parties contesting in the elections.</li>
   <li>Enter the contest name in the specified field.</li>
   <li>Enter the candidate names in the specified fields and the number of seats won by that party.</li>
   <li>Select the checkboxes beside the parties to group them into the winning coalition.
   <li>In the Election Results table fill in the results for the respective constituencies.</li>
   <li>Set the desired risk limit.</li>
   <li>Click on compute when you have successfully filled in all the fields.</li>
   <li>Audit the constituencies simultaneously using one of two Ballot Polling tools whose links
       are present on the top of this webpage. Update the table in case any constituency outcome
       changes and hence recompute the risk limits and continue the audit.
   </li>
</ul>
  </div>
</div>
</p>

<div class="panel panel-primary">
  <div class="panel-heading">Risk Computing Tool</div>
    <div class="panel-body">
        <form action="#" method="get">
            <div class="panel panel-default">
                <div class="panel-heading">Contest Information</div>
                    <div class="panel-body">
                        <div class="form-group">
                                <label for="nSeats">Total Number of Seats</label>
                                <input class="form-control" placeholder="Number of Constituencies eg.543" type="number" min="0" size="10" name="nSeats" id="nSeats" value="0"/>&nbsp;&nbsp;<br>
                                <label for="nCandi">Number of Parties:</label>
                                <input class="form-control" placeholder="Number of Parties eg.10" value="0" type="number" min="0" size="10" name="nCandi" id="nCandi" />&nbsp;&nbsp;<br>
                                <div class="contestList"></div>
                                    
                        </div>
                    </div>
                </div>
            <div class="overallTable"></div>
            <!--div class="panel panel-default">
                <div class="panel-heading">Coalition Parties</div>
                    <div class="panel-body">
                        <label for="coalition">Parties in Winning Coalition
                        <<input class="form-control" type="text" size="10" name="risk" id="risk" placeholder />
                    </div>
            </div-->
            <div class="panel panel-default">
                <div class="panel-heading">Audit parameters</div>
                    <div class="panel-body">
                        <label for="risk">Overall Risk limit:</label>
                        <input class="form-control" type="text" size="10" name="risk" id="risk" value="5%" />
                    </div>
            </div>
        </form>
        <div class="panel panel-default">
            <div class="panel-heading">Risk-limits for various constituencies</div>
                <div class="panel-body">
                    <button type="button" class="btn btn-success" onclick="findRisks()">Compute</button>
                    <div class="newRisks"></div>
                </div>
        </div>
    </div>
</div>



<!--p>
   Taking a larger initial sample can avoid needing to expand the sample later,
   depending on the rate of ballots for each candidate in the sample.
   Avoiding &quot;escalation&quot; can make the audit less complicated.
</p>

<h3 id="considerations">Considerations for deciding which contests to audit together</h3>

<p>
   The number of ballots the audit must examine before stopping depends on the smallest
   diluted margin among the contests to be audited together (as well as the risk limit,
   the errors the audit finds, and so on).
   All else equal, the larger the diluted margin is, the smaller the sample size needs to be.
</p>

<p>
   Because the diluted margin is the smallest margin in votes divided by the total number of
   ballots cast in all the contests under audit,
   auditing small contests together with large contests can be inefficient:
   Dividing the vote margin in small contests by the number of ballots cast in large contests
   can make the diluted margin very small, which makes the required sample very large.
</p>

<p>
   Generally, if two contests overlap substantially&mdash;for instance, if both are jurisdiction-wide
   contests&mdash;it is more economical
   to audit them together:  Fewer ballots will need to be inspected in all.
   Conversely, if two contests do not overlap at all, it is more efficient to audit them separately.
</p>


<p>
   Auditing small contests together with (overlapping) large contests generally is not efficient unless the
   vote margin in the small contests is a substantial fraction of the vote margin in the large
   contests.
   That is, auditing small contests that have large percentage margins together with large contests that
   have small percentage margins
   can be efficient, but auditing small contests together with large contests
   that have comparable vote margins generally is not efficient, because it makes the
   diluted margin of the combination much smaller.
</p>

<p>
   The tool above can be used to explore whether it makes sense to audit a collection of contests
   together by checking whether the expected sample size when they are audited
   together is greater than the sum of the expected sample sizes when they are audited
   separately.
   (If you experiment with different groupings of contests, be sure to change the entry for
   &quot;Ballots cast in all contests&quot; to reflect only the contests that are to be audited
   together.)
</p-->



<!--p><a href="#" class="toggleStartingSampleNotes">Show technical notes.</a></p>
<p class="startingSampleNotes notes">
   Say the desired overall confidence level is $$ 1 - \epsilon $$
</p>   
<p class="startingSampleNotes notes">
    We can audit the constituency <em>i</em> in which the winner has won to confidence level 
    $$1-\epsilon^{\alpha_i} $$.
</p>
<p class="startingSampleNotes notes">
   where \(\alpha_i\) is some constant between 0 and 1. A <em>flipset</em> is a set of constituencies
   whose result when flipped will alter the election results. The \(\alpha_i\) must be such that
   in any <em>flipset</em>, the sum of the \(\alpha_i\) of the constituencies must sum up to greater than
   1. 
</p>
<p class="startingSampleNotes notes">
    The cost of auditing constituency i to risk limit \(\alpha_i\) where the diluted margin is 
    \(\mu_i\) is proportional to \(\frac{\alpha_i}{\mu_i}\). Our tool solves the Linear Program
    of minimizing the total cost of auditing the constituencies in which the winner won subject to
    the constraints that \(0<=\alpha_i<=1\) and for every minimal flipset, \(\sum \alpha_i >=1\).
</p-->
<!--h2>Random sampling</h2>

<p>
   The next tool helps generate a pseudo-random sample of ballots.
   To start,
   input a random seed with at least 20 digits (generated by rolling a 10-sided die, for instance),
   the number of ballots from which you want a sample, and the number of ballots you want in the sample.
   Further below, there is a form to help find the individual, randomly selected
   ballots among the batches in which ballots are stored.
</p>

    <form action="#" method="get">
        <fieldset>
            <legend>Pseudo-Random Sample of Ballots</legend>
            <div>
                <label for="seedValue">Seed:</label>
                <input type="text" size="25" name="seedValue" id="seedValue" onblur="clearList();"
                       value="Input seed here" />
            </div>
            <div>
                <label for="nObj">Number of ballots:</label>
                <input type="text" size="10" name="nObj" id="nObj" onblur="clearList();" value="1000"/>
            </div>
            <div>
                 <label for="samNum">Current sample number:</label>
                 <input type="text" size="10" name="samNum" id="samNum" editable="false" value="1"/>
                 <br />
                 <label for="samMany">Draw this many ballots:</label>
                 <input type="text" size="10" name="samMany" id="samMany" value="1"/>
                 <input type="button" name="nextItem" id="nextItem" value="draw sample" />
                 <input type="button" name="reset" id="reset" value="reset" />
            </div>
            <br />
            <div>
               <label for="list">Ballots selected:</label>
               <input type="checkbox" name="showSequence" id="showSequence" value="showSequence" checked />
               <label for="showSequence">show sequence numbers</label>

               <input type="checkbox" name="showHash" id="showHash" value="showHash" />
               <label for="showHash">show hash values</label>
               <br />
               <textarea rows="10" cols="80" name="list" id="list" readonly="readonly"></textarea>
            </div>
            <div>
               <label for="sortedList">Ballots selected, sorted:</label><br />
               <textarea rows="10" cols="80" name="sortedList" id="sortedList" readonly="readonly"></textarea>
            </div>
            <div>
               <label for="sortedDedupeList">Ballots selected, sorted, duplicates removed:</label><br />
               <textarea rows="10" cols="80" name="sortedDedupeList" id="sortedDedupeList" readonly="readonly"></textarea>
            </div>
            <div>
               <label for="duplicates">Repeated ballots:</label><br />
               <textarea rows="10" cols="80" name="duplicates" id="duplicates" readonly="readonly"></textarea>
            </div>
        </fieldset>

</form>

<p>
   <a href="#" class="toggleRandomSampleNotes">Show technical notes.</a>
</p>

<p class="randomSampleNotes notes">
   The &quot;seed,&quot; concatenated with a comma and the &quot;Sample number,&quot; is passed through the
   SHA-256 hash function.
   The result is displayed as &quot;Hashed value (for testing)&quot;.
   The hashed value, interpreted as a hexadecimal number, is divided by
   &quot;Number of objects from which to sample.&quot;
   One is added to the remainder of that division to get &quot;Randomly selected item,&quot;
   which will be a number between 1 and &quot;Number of objects from which to sample,&quot; inclusive.
   Clicking &quot;draw sample&quot; successively adds one to &quot;Sample number&quot; and
   recomputes &quot;Hashed value&quot; and &quot;Randomly selected item&quot;
   &quot;Draw this many objects&quot; times.
   Selected items accumulate in &quot;Ballots selected&quot; (and &quot;Ballots selected, sorted&quot;),
   which reset if the seed or the number of objects changes.
   The same ballot might be selected more than once.
   Duplicates are removed in
   &quot;Ballots selected, duplicates removed.&quot;
   Ballots selected more than once, and the frequencies of those ballots, are in
   &quot;Repeated ballots.&quot;
   Clicking the &quot;reset&quot; button clears the history but leaves the seed.
</p>

<p class="randomSampleNotes notes">
   I learned about this method of generating pseudo-random numbers from
   <a href="http://people.csail.mit.edu/rivest/">Ronald L. Rivest</a>;
   it is related to a method described in
   <a href="http://tools.ietf.org/html/rfc3797">http://tools.ietf.org/html/rfc3797</a>.
   The SHA-256 hash algorithm produces hash values that are hard to predict from the input.
   They are also roughly equidistributed as the input varies.
   The advantages of this approach for election auditing and some other applications
   include the following:
</p>

<ul class="randomSampleNotes notes">
    <li> The SH-256 algorithm is public and many implementations are available in many languages.
         (The Javascript implementation used by this page was written by Brian Turek;
         The JavaScript routines for arithmetic long integers&mdash;the SHA-256 hashed values&mdash;were
         written by Leemon Baird).
    </li>
    <li>
        Given the seed, anyone can verify that the sequence of numbers generated was
        correct&mdash;that it indeed comes from applying SHA-256.
    </li>
    <li>
        Unless the seed is known, the sequence of values generated is unpredictable (so the result
        is hard to &quot;game&quot;).
        It is very hard to distinguish the output from independent, uniformly distributed samples.
    </li>
</ul>

<p class="randomSampleNotes notes">
   For comparison, a reference implementation of this approach in Python written by
   <a href="http://people.csail.mit.edu/rivest/">Ronald L. Rivest</a> is available at
   <a href=" http://people.csail.mit.edu/rivest/sampler.py">http://people.csail.mit.edu/rivest/sampler.py</a>.
</p>

<p class="randomSampleNotes notes">
      For more detail, see
   <a href="http://statistics.berkeley.edu/~stark/Java/Html/sha256Rand.htm">http://statistics.berkeley.edu/~stark/Java/Html/sha256Rand.htm</a>.
</p>



<h2>
   Find ballots using a ballot manifest
</h2>

<p>
   Generally, ballots will be stored in batches, for instance, separated by precinct and mode of voting.
   To make it easier to find individual ballots, it helps to have a <em>ballot manifest</em>
   that describes how the ballots are stored.
   For instance, we might have 1,000 ballots stored as follows:
</p>

<table>
   <tr>
      <th>Batch label</th><th>ballots</th>
   </tr>
   <tr>
      <td>Polling place precinct 1</td> <td>130</td>
   </tr>
      <td>Vote by mail precinct 1</td>  <td>172</td>
   </tr>
   <tr>
      <td>Polling place precinct 2</td> <td>112</td>
   </tr>
      <td>Vote by mail precinct 2</td>  <td>201</td>
   </tr>
   <tr>
      <td>Polling place precinct 3</td> <td>197</td>
   </tr>
      <td>Vote by mail precinct 3</td>  <td>188</td>
   </tr>
</table>


<p>
   If ballot 500 is selected for audit, which ballot is that?
   If we take the listing of batches in the order given by the manifest, and we
   require that within each batch, the ballots are in an order that does not
   change during the audit, then the 500th ballot is the 86th ballot among the vote by mail ballots
   for precinct 2:
   The first three batches have a total of 130+172+112 = 414 ballots.
   The first ballot in the fourth batch is ballot 415.
   Ballot 500 is the 86th ballot in the fourth batch.
</p>

<p>
   The ballot look-up tool transforms a list of ballot numbers and a ballot manifest
   into a list of ballots in each batch.
   Batch labels should not contain commas.
   Use a comma to separate each batch label from the number of ballots in that batch
   (or the range of ballot numbers or the set of ballot identifiers&mdash;see below).
   The manifest should have one line per batch and no empty lines.
</p>

<p>
   For instance, to input the ballot manifest above, you would enter:
</p>

<p>
<pre>
Polling place precinct 1, 130
Vote by mail precinct 1, 172
Polling place precinct 2, 112
Vote by mail precinct 2, 201
Polling place precinct 3, 197
Vote by mail precinct 3, 188
</pre>
</p>

<p>
   Some jurisdictions number the ballots cast in an election.
   If all the ballots in an election are numbered sequentially, the numbers on the ballots that contain
   a particular contest might not be sequential.
   For instance, an election might cover precincts 1, 2, and 3, but
   only voters in precincts 1 and 3 are eligible to vote in the contests to be audited with the current sample.
   In the previous example, suppose that the jurisdiction had stamped numbers on all the ballots, sequentially, so that
   the ballots from the polling place in precinct 1 were numbered 1 to 130, the vote by mail ballots from precinct 1 were
   numbered 131 to 302, the ballots from the polling place in precinct 2 were numbered 303 to 414, and so on,
   as summarized in the following table:
</p>

<table>
   <tr>
      <th>Batch label</th><th>ballot range</th>
   </tr>
   <tr>
      <td>Polling place precinct 1</td> <td>1 to 130</td>
   </tr>
      <td>Vote by mail precinct 1</td>  <td>131 to 302</td>
   </tr>
   <tr>
      <td>Polling place precinct 2</td> <td>303 to 414</td>
   </tr>
      <td>Vote by mail precinct 2</td>  <td>415 to 615</td>
   </tr>
   <tr>
      <td>Polling place precinct 3</td> <td>616 to 812</td>
   </tr>
      <td>Vote by mail precinct 3</td>  <td>813 to 994</td>
   </tr>
   <tr>
      <td>Provisional ballots for precinct 1</td> <td>996, 998, 1000</td>
   </tr>
   <tr>
      <td>Provisional ballots for precinct 2</td> <td>997</td>
   </tr>
   <tr>
      <td>Provisional ballots for precinct 3</td> <td>995, 999</td>
   </tr>
</table>

<p>
   Since the ballots already have numbers on them, it makes sense to look them up using those numbers.
   If we were auditing a collection of contests that included only precincts 1 and 3, the ballots subject to audit
   would be the 686 ballots labeled 1 to 130, 131 to 302, 616 to 812, and 813 to 994, and
   995, 996, 998, and 1000.
   In this case, the ballot manifest would include <em>only</em> the six batches that comprise precincts 1 and 3,
   not all eight batches; there are only 686 ballots in these batches.
   Each line in the manifest would consist of a batch label and a range of ballot numbers,
   where the range is denoted by a colon,
   or of a batch label and a set of ballot identifiers in parentheses, separated by spaces.
   Ballot ranges cannot have gaps: There can be no missing numbers within the range for
   any single batch.
   (If there is in fact a gap, input the numbers as a set of identifiers, rather than as a range.)
   Again, separate the label from the range or set of ballot numbers by a comma.
   The label must not contain any commas,
   and the range of ballot numbers or set of identifiers must not contain commas.
   In this example, we would enter the ballot manifest as follows:
</p>

<p>
<pre>
Polling place precinct 1, 1:130
Vote by mail precinct 1, 131:302
Polling place precinct 3, 616:812
Vote by mail precinct 3, 813:994
Provisional precinct 1, (996 998 1000)
Provisional precinct 3, (995 999)
</pre>
</p>

<p>
   The total number of ballots in the manifest must equal the number cast in the contests that are to be
   audited together using the sample (686 in this example).
</p>

    <form action="#" method="get">
        <fieldset>
            <legend>Ballot look-up tool</legend>
            <div>
                <label for="manifest">Ballot manifest: Each line must have a batch label, a comma, and one of the following:<br />
                                      &nbsp;&nbsp;(i) the number of ballots in the batch <br />
                                      &nbsp;&nbsp;(ii) a range specified with a colon (e.g., 131:302), or <br />
                                      &nbsp;&nbsp;(iii) a list of ballot identifiers within parentheses, separated by spaces (e.g., (996 998 1000)).<br />
                                      Each line should have exactly one comma.<br />
                                      </label><br />
                <textarea rows="25" cols="80" name="manifest" id="manifest"></textarea>
            </div>
            <div>
               <label for="ballotList">Ballots to look up (separated by commas):</label><br />
               <textarea rows="10" cols="80" name="ballotList" id="ballotList" ></textarea>
            </div>
            <div>
                <input type="button" id="lookUpBallot" name="lookUpBallot" value="look up ballots" />
            </div>
            <div>
               <label for="lookUp">Sorted lookup table:</label><br />
               <textarea rows="25" cols="80" name="lookUp" id="lookUp" readonly="readonly"></textarea>
            </div>
        </fieldset>

</form>

<h2>Wald's Probability ratio test</h2>

<p>
   The audit looks at the winner and all the losers together. Every vote for the winner increases
   the value of the probability ratio. Every vote for any of the losers decreases
   that value. If sufficient evidence is found that the election is correct, the audit stops.
   This is indicated by the cell representing the ratio becoming green in colour.
   If the cell is red in colour, we have to continue the auditing.
</p>



<form action="#" method="get">
        <fieldset>
            <legend>Audit progress</legend>
              <div class="testTable"></div>
        </fieldset>

</form>

<p>
   <a href="#" class="toggleEndingSampleNotes">Show technical notes.</a>
</p>

<p class="endingSampleNotes notes">
   The stopping rule implements the following formula from
   <a href="http://statistics.berkeley.edu/~stark/Preprints/gentle12.pdf">AGI</a>:
   FIX ME!
</p-->
    </div>

<!-- Tab panes -->
    <div role="tabpanel" class="tab-pane" id="technical">
        <div class="panel panel-primary">
            <div class="panel-heading">Technical Notes</div>
            <div class="panel-body">
                <p >
                Say the desired overall confidence level is $$ 1 - \epsilon $$
                </p>   
                <p >
                    We can audit the constituency <em>i</em> in which the winner has won to confidence level 
                    $$1-\epsilon^{\alpha_i} $$
                </p>
                <p >
                where \(\alpha_i\) is some constant between 0 and 1. A <em>flipset</em> is a set of constituencies
                whose result when flipped will alter the election results. The \(\alpha_i\) must be such that
                in any <em>flipset</em>, the sum of the \(\alpha_i\) of the constituencies must sum up to greater than
                1. 
                </p>
                <p >
                    The cost of auditing constituency i to risk limit \(\alpha_i\) where the diluted margin is 
                    \(\mu_i\) is proportional to \(\frac{\alpha_i}{\mu_i}\). Our tool solves the Linear Program
                    of minimizing the total cost of auditing the constituencies in which the winner won subject to
                    the constraints that \(0<=\alpha_i<=1\) and for every minimal flipset, \(\sum \alpha_i >=1\).
                </p>
            </div>
        </div>
    </div>
</div>

</body>

</html>
